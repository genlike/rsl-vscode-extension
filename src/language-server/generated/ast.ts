/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type ActionType = ActionTypeExtendedRef | ActionTypeOriginal;

export const ActionType = 'ActionType';

export function isActionType(item: unknown): item is ActionType {
    return reflection.isInstance(item, ActionType);
}

export type ActiveElement = ActiveEvent | ActiveFlow | ActiveTask;

export const ActiveElement = 'ActiveElement';

export function isActiveElement(item: unknown): item is ActiveElement {
    return reflection.isInstance(item, ActiveElement);
}

export type ActiveEventType = ActiveEventTypeExtendedRef | ActiveEventTypeOriginal;

export const ActiveEventType = 'ActiveEventType';

export function isActiveEventType(item: unknown): item is ActiveEventType {
    return reflection.isInstance(item, ActiveEventType);
}

export type ActiveFlowType = ActiveFlowTypeExtendedRef | ActiveFlowTypeOriginal;

export const ActiveFlowType = 'ActiveFlowType';

export function isActiveFlowType(item: unknown): item is ActiveFlowType {
    return reflection.isInstance(item, ActiveFlowType);
}

export type ActiveStructureElement = Actor | Stakeholder;

export const ActiveStructureElement = 'ActiveStructureElement';

export function isActiveStructureElement(item: unknown): item is ActiveStructureElement {
    return reflection.isInstance(item, ActiveStructureElement);
}

export type ActiveTaskType = ActiveTaskTypeExtendedRef | ActiveTaskTypeOriginal;

export const ActiveTaskType = 'ActiveTaskType';

export function isActiveTaskType(item: unknown): item is ActiveTaskType {
    return reflection.isInstance(item, ActiveTaskType);
}

export type ActorType = ActorTypeExtendedRef | ActorTypeOriginal;

export const ActorType = 'ActorType';

export function isActorType(item: unknown): item is ActorType {
    return reflection.isInstance(item, ActorType);
}

export type BehaviorElement = ActiveElement | StateMachine;

export const BehaviorElement = 'BehaviorElement';

export function isBehaviorElement(item: unknown): item is BehaviorElement {
    return reflection.isInstance(item, BehaviorElement);
}

export type CheckType = CheckTypeExtendedRef | CheckTypeOriginal;

export const CheckType = 'CheckType';

export function isCheckType(item: unknown): item is CheckType {
    return reflection.isInstance(item, CheckType);
}

export type ConditionalExpression = IfExpression | RepeatExpression;

export const ConditionalExpression = 'ConditionalExpression';

export function isConditionalExpression(item: unknown): item is ConditionalExpression {
    return reflection.isInstance(item, ConditionalExpression);
}

export type ConstraintSubType = ConstraintSubTypeExtendedRef | ConstraintSubTypeOriginal;

export const ConstraintSubType = 'ConstraintSubType';

export function isConstraintSubType(item: unknown): item is ConstraintSubType {
    return reflection.isInstance(item, ConstraintSubType);
}

export type ConstraintType = ConstraintTypeExtendedRef | ConstraintTypeOriginal;

export const ConstraintType = 'ConstraintType';

export function isConstraintType(item: unknown): item is ConstraintType {
    return reflection.isInstance(item, ConstraintType);
}

export type DataEntityClusterType = DataEntityClusterTypeExtendedRef | DataEntityClusterTypeOriginal;

export const DataEntityClusterType = 'DataEntityClusterType';

export function isDataEntityClusterType(item: unknown): item is DataEntityClusterType {
    return reflection.isInstance(item, DataEntityClusterType);
}

export type DataEntityGeneric = DataEntity | DataEntityCluster;

export const DataEntityGeneric = 'DataEntityGeneric';

export function isDataEntityGeneric(item: unknown): item is DataEntityGeneric {
    return reflection.isInstance(item, DataEntityGeneric);
}

export type DataEntitySubType = DataEntitySubTypeExtendedRef | DataEntitySubTypeOriginal;

export const DataEntitySubType = 'DataEntitySubType';

export function isDataEntitySubType(item: unknown): item is DataEntitySubType {
    return reflection.isInstance(item, DataEntitySubType);
}

export type DataEntityType = DataEntityTypeExtendedRef | DataEntityTypeOriginal;

export const DataEntityType = 'DataEntityType';

export function isDataEntityType(item: unknown): item is DataEntityType {
    return reflection.isInstance(item, DataEntityType);
}

export type DoubleOrInt = number | string;

export type ForeignKeyOnDeleteType = ForeignKeyOnDeleteTypeExtendedRef | ForeignKeyOnDeleteTypeOriginal;

export const ForeignKeyOnDeleteType = 'ForeignKeyOnDeleteType';

export function isForeignKeyOnDeleteType(item: unknown): item is ForeignKeyOnDeleteType {
    return reflection.isInstance(item, ForeignKeyOnDeleteType);
}

export type FRType = FRTypeExtendedRef | FRTypeOriginal;

export const FRType = 'FRType';

export function isFRType(item: unknown): item is FRType {
    return reflection.isInstance(item, FRType);
}

export type GlossaryTermType = GlossaryTermTypeExtendedRef | GlossaryTermTypeOriginal;

export const GlossaryTermType = 'GlossaryTermType';

export function isGlossaryTermType(item: unknown): item is GlossaryTermType {
    return reflection.isInstance(item, GlossaryTermType);
}

export type GoalSubType = GoalSubTypeExtendedRef | GoalSubTypeOriginal;

export const GoalSubType = 'GoalSubType';

export function isGoalSubType(item: unknown): item is GoalSubType {
    return reflection.isInstance(item, GoalSubType);
}

export type GoalType = GoalTypeExtendedRef | GoalTypeOriginal;

export const GoalType = 'GoalType';

export function isGoalType(item: unknown): item is GoalType {
    return reflection.isInstance(item, GoalType);
}

export type IncludeElementGeneric = IncludeAll | IncludeElement;

export const IncludeElementGeneric = 'IncludeElementGeneric';

export function isIncludeElementGeneric(item: unknown): item is IncludeElementGeneric {
    return reflection.isInstance(item, IncludeElementGeneric);
}

export type MetricType = MetricTypeExtendedRef | MetricTypeOriginal;

export const MetricType = 'MetricType';

export function isMetricType(item: unknown): item is MetricType {
    return reflection.isInstance(item, MetricType);
}

export type OperationTargetType = 'button' | 'checkbox' | 'element' | 'listByValue' | 'readFrom' | 'writeTo';

export const OperationTargetType = 'OperationTargetType';

export function isOperationTargetType(item: unknown): item is OperationTargetType {
    return reflection.isInstance(item, OperationTargetType);
}

export type OperationTargetType_button = 'button';

export type OperationTargetType_checkbox = 'checkbox';

export type OperationTargetType_element = 'element';

export type OperationTargetType_listByValue = 'listByValue';

export type OperationTargetType_readFrom = 'readFrom';

export type OperationTargetType_writeTo = 'writeTo';

export type OtherElement = GlossaryTerm | RiskGeneric | Stereotype | TypeExtended;

export const OtherElement = 'OtherElement';

export function isOtherElement(item: unknown): item is OtherElement {
    return reflection.isInstance(item, OtherElement);
}

export type PackageAbstract = PackageSystem;

export const PackageAbstract = 'PackageAbstract';

export function isPackageAbstract(item: unknown): item is PackageAbstract {
    return reflection.isInstance(item, PackageAbstract);
}

export type PassiveStructureElement = Data | DataEntityGeneric | DataEnumeration;

export const PassiveStructureElement = 'PassiveStructureElement';

export function isPassiveStructureElement(item: unknown): item is PassiveStructureElement {
    return reflection.isInstance(item, PassiveStructureElement);
}

export type Percentage = string;

export type PriorityType = PriorityTypeExtendedRef | PriorityTypeOriginal;

export const PriorityType = 'PriorityType';

export function isPriorityType(item: unknown): item is PriorityType {
    return reflection.isInstance(item, PriorityType);
}

export type QRSubType = QRSubTypeExtendedRef | QRSubTypeOriginal;

export const QRSubType = 'QRSubType';

export function isQRSubType(item: unknown): item is QRSubType {
    return reflection.isInstance(item, QRSubType);
}

export type QRType = QRTypeExtendedRef | QRTypeOriginal;

export const QRType = 'QRType';

export function isQRType(item: unknown): item is QRType {
    return reflection.isInstance(item, QRType);
}

export type QualifiedName = string;

export type QualifiedNameWithWildcard = string;

export type RelationType = RelationTypeExtendedRef | RelationTypeOriginal;

export const RelationType = 'RelationType';

export function isRelationType(item: unknown): item is RelationType {
    return reflection.isInstance(item, RelationType);
}

export type Requirement = Constraint | FR | Goal | QR | UseCase | UserStory;

export const Requirement = 'Requirement';

export function isRequirement(item: unknown): item is Requirement {
    return reflection.isInstance(item, Requirement);
}

export type RequirementsRelationType = RequirementsRelationTypeExtendedRef | RequirementsRelationTypeOriginal;

export const RequirementsRelationType = 'RequirementsRelationType';

export function isRequirementsRelationType(item: unknown): item is RequirementsRelationType {
    return reflection.isInstance(item, RequirementsRelationType);
}

export type RiskGeneric = Risk | Vulnerability;

export const RiskGeneric = 'RiskGeneric';

export function isRiskGeneric(item: unknown): item is RiskGeneric {
    return reflection.isInstance(item, RiskGeneric);
}

export type RiskSubType = RiskSubTypeExtendedRef | RiskSubTypeOriginal;

export const RiskSubType = 'RiskSubType';

export function isRiskSubType(item: unknown): item is RiskSubType {
    return reflection.isInstance(item, RiskSubType);
}

export type RiskTreatmentType = RiskTreatmentTypeExtendedRef | RiskTreatmentTypeOriginal;

export const RiskTreatmentType = 'RiskTreatmentType';

export function isRiskTreatmentType(item: unknown): item is RiskTreatmentType {
    return reflection.isInstance(item, RiskTreatmentType);
}

export type RiskType = RiskTypeExtendedRef | RiskTypeOriginal;

export const RiskType = 'RiskType';

export function isRiskType(item: unknown): item is RiskType {
    return reflection.isInstance(item, RiskType);
}

export type ScenarioType = ScenarioTypeExtendedRef | ScenarioTypeOriginal;

export const ScenarioType = 'ScenarioType';

export function isScenarioType(item: unknown): item is ScenarioType {
    return reflection.isInstance(item, ScenarioType);
}

export type StakeholderSubType = StakeholderSubTypeExtendedRef | StakeholderSubTypeOriginal;

export const StakeholderSubType = 'StakeholderSubType';

export function isStakeholderSubType(item: unknown): item is StakeholderSubType {
    return reflection.isInstance(item, StakeholderSubType);
}

export type StakeholderType = StakeholderTypeExtendedRef | StakeholderTypeOriginal;

export const StakeholderType = 'StakeholderType';

export function isStakeholderType(item: unknown): item is StakeholderType {
    return reflection.isInstance(item, StakeholderType);
}

export type StateMachineType = StateMachineTypeExtendedRef | StateMachineTypeOriginal;

export const StateMachineType = 'StateMachineType';

export function isStateMachineType(item: unknown): item is StateMachineType {
    return reflection.isInstance(item, StateMachineType);
}

export type States = State;

export const States = 'States';

export function isStates(item: unknown): item is States {
    return reflection.isInstance(item, States);
}

export type StepSubSubType = StepSubSubTypeExtendedRef | StepSubSubTypeOriginal;

export const StepSubSubType = 'StepSubSubType';

export function isStepSubSubType(item: unknown): item is StepSubSubType {
    return reflection.isInstance(item, StepSubSubType);
}

export type StepSubType = StepSubTypeExtendedRef | StepSubTypeOriginal;

export const StepSubType = 'StepSubType';

export function isStepSubType(item: unknown): item is StepSubType {
    return reflection.isInstance(item, StepSubType);
}

export type StepType = StepTypeExtendedRef | StepTypeOriginal;

export const StepType = 'StepType';

export function isStepType(item: unknown): item is StepType {
    return reflection.isInstance(item, StepType);
}

export type StereotypeType = StereotypeTypeExtendedRef | StereotypeTypeOriginal;

export const StereotypeType = 'StereotypeType';

export function isStereotypeType(item: unknown): item is StereotypeType {
    return reflection.isInstance(item, StereotypeType);
}

export type StructureElement = ActiveStructureElement | PassiveStructureElement;

export const StructureElement = 'StructureElement';

export function isStructureElement(item: unknown): item is StructureElement {
    return reflection.isInstance(item, StructureElement);
}

export type SystemConcept = SystemElement | SystemRelation | SystemSet;

export const SystemConcept = 'SystemConcept';

export function isSystemConcept(item: unknown): item is SystemConcept {
    return reflection.isInstance(item, SystemConcept);
}

export type SystemElement = BehaviorElement | IncludeElementGeneric | OtherElement | Requirement | StructureElement | Test;

export const SystemElement = 'SystemElement';

export function isSystemElement(item: unknown): item is SystemElement {
    return reflection.isInstance(item, SystemElement);
}

export type SystemRelation = ElementsRelation | RequirementsRelation | SystemsRelation | TestsRelation;

export const SystemRelation = 'SystemRelation';

export function isSystemRelation(item: unknown): item is SystemRelation {
    return reflection.isInstance(item, SystemRelation);
}

export type SystemSet = Theme | View;

export const SystemSet = 'SystemSet';

export function isSystemSet(item: unknown): item is SystemSet {
    return reflection.isInstance(item, SystemSet);
}

export type SystemsRelationCategory = SystemsRelationCategoryExtendedRef | SystemsRelationCategoryOriginal;

export const SystemsRelationCategory = 'SystemsRelationCategory';

export function isSystemsRelationCategory(item: unknown): item is SystemsRelationCategory {
    return reflection.isInstance(item, SystemsRelationCategory);
}

export type SystemsRelationType = SystemsRelationTypeExtendedRef | SystemsRelationTypeOriginal;

export const SystemsRelationType = 'SystemsRelationType';

export function isSystemsRelationType(item: unknown): item is SystemsRelationType {
    return reflection.isInstance(item, SystemsRelationType);
}

export type SystemSubType = SystemSubTypeExtendedRef | SystemSubTypeOriginal;

export const SystemSubType = 'SystemSubType';

export function isSystemSubType(item: unknown): item is SystemSubType {
    return reflection.isInstance(item, SystemSubType);
}

export type SystemType = SystemTypeExtendedRef | SystemTypeOriginal;

export const SystemType = 'SystemType';

export function isSystemType(item: unknown): item is SystemType {
    return reflection.isInstance(item, SystemType);
}

export type Test = AcceptanceCriteriaTest | DataEntityTest | StateMachineTest | UseCaseTest;

export const Test = 'Test';

export function isTest(item: unknown): item is Test {
    return reflection.isInstance(item, Test);
}

export type TestScenarioType = TestScenarioTypeExtendedRef | TestScenarioTypeOriginal;

export const TestScenarioType = 'TestScenarioType';

export function isTestScenarioType(item: unknown): item is TestScenarioType {
    return reflection.isInstance(item, TestScenarioType);
}

export type TestsRelationType = TestsRelationTypeExtendedRef | TestsRelationTypeOriginal;

export const TestsRelationType = 'TestsRelationType';

export function isTestsRelationType(item: unknown): item is TestsRelationType {
    return reflection.isInstance(item, TestsRelationType);
}

export type TestType = TestTypeExtendedRef | TestTypeOriginal;

export const TestType = 'TestType';

export function isTestType(item: unknown): item is TestType {
    return reflection.isInstance(item, TestType);
}

export type TypeExtended = ActionTypeExtended | ActiveEventTypeExtended | ActiveFlowTypeExtended | ActiveTaskTypeExtended | ActorTypeExtended | CheckTypeExtended | ConstraintSubTypeExtended | ConstraintTypeExtended | DataAttributeTypeExtended | DataEntityClusterTypeExtended | DataEntitySubTypeExtended | DataEntityTypeExtended | FRTypeExtended | ForeignKeyOnDeleteTypeExtended | GlossaryTermTypeExtended | GoalSubTypeExtended | GoalTypeExtended | MetricTypeExtended | PriorityTypeExtended | QRSubTypeExtended | QRTypeExtended | RelationTypeExtended | RequirementsRelationTypeExtended | RiskSubTypeExtended | RiskTreatmentTypeExtended | RiskTypeExtended | ScenarioTypeExtended | StakeholderSubTypeExtended | StakeholderTypeExtended | StateMachineTypeExtended | StepSubSubTypeExtended | StepSubTypeExtended | StepTypeExtended | StereotypeTypeExtended | SystemSubTypeExtended | SystemTypeExtended | SystemsRelationCategoryExtended | SystemsRelationTypeExtended | TestScenarioTypeExtended | TestTypeExtended | TestsRelationTypeExtended | UseCaseTypeExtended | UserStoryTypeExtended | VulnerabilityAttackVectorExtended | VulnerabilitySubTypeExtended | VulnerabilityTypeExtended;

export const TypeExtended = 'TypeExtended';

export function isTypeExtended(item: unknown): item is TypeExtended {
    return reflection.isInstance(item, TypeExtended);
}

export type UseCaseType = UseCaseTypeExtendedRef | UseCaseTypeOriginal;

export const UseCaseType = 'UseCaseType';

export function isUseCaseType(item: unknown): item is UseCaseType {
    return reflection.isInstance(item, UseCaseType);
}

export type UserStoryType = UserStoryTypeExtendedRef | UserStoryTypeOriginal;

export const UserStoryType = 'UserStoryType';

export function isUserStoryType(item: unknown): item is UserStoryType {
    return reflection.isInstance(item, UserStoryType);
}

export type VulnerabilityAttackVector = VulnerabilityAttackVectorExtendedRef | VulnerabilityAttackVectorOriginal;

export const VulnerabilityAttackVector = 'VulnerabilityAttackVector';

export function isVulnerabilityAttackVector(item: unknown): item is VulnerabilityAttackVector {
    return reflection.isInstance(item, VulnerabilityAttackVector);
}

export type VulnerabilitySubType = VulnerabilitySubTypeExtendedRef | VulnerabilitySubTypeOriginal;

export const VulnerabilitySubType = 'VulnerabilitySubType';

export function isVulnerabilitySubType(item: unknown): item is VulnerabilitySubType {
    return reflection.isInstance(item, VulnerabilitySubType);
}

export type VulnerabilityType = VulnerabilityTypeExtendedRef | VulnerabilityTypeOriginal;

export const VulnerabilityType = 'VulnerabilityType';

export function isVulnerabilityType(item: unknown): item is VulnerabilityType {
    return reflection.isInstance(item, VulnerabilityType);
}

export interface AcceptanceCriteria extends AstNode {
    readonly $container: Constraint | FR | Goal | QR | Risk | UseCase | UserStory;
    readonly $type: 'AcceptanceCriteria';
    criteriaR?: AcceptanceCriteriaRule
    criteriaS?: AcceptanceCriteriaScenario
    description?: string
    isAbstract: boolean
    isConcrete: boolean
    name: string
    nameAlias?: string
    tags: Array<Tag>
    type: TestType
}

export const AcceptanceCriteria = 'AcceptanceCriteria';

export function isAcceptanceCriteria(item: unknown): item is AcceptanceCriteria {
    return reflection.isInstance(item, AcceptanceCriteria);
}

export interface AcceptanceCriteriaRule extends AstNode {
    readonly $container: AcceptanceCriteria | AcceptanceCriteriaTest;
    readonly $type: 'AcceptanceCriteriaRule';
    rule: string
}

export const AcceptanceCriteriaRule = 'AcceptanceCriteriaRule';

export function isAcceptanceCriteriaRule(item: unknown): item is AcceptanceCriteriaRule {
    return reflection.isInstance(item, AcceptanceCriteriaRule);
}

export interface AcceptanceCriteriaScenario extends AstNode {
    readonly $container: AcceptanceCriteria | AcceptanceCriteriaTest;
    readonly $type: 'AcceptanceCriteriaScenario';
    given: Array<string>
    scenario: string
    then: Array<string>
    when: Array<string>
}

export const AcceptanceCriteriaScenario = 'AcceptanceCriteriaScenario';

export function isAcceptanceCriteriaScenario(item: unknown): item is AcceptanceCriteriaScenario {
    return reflection.isInstance(item, AcceptanceCriteriaScenario);
}

export interface AcceptanceCriteriaTest extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'AcceptanceCriteriaTest';
    criteriaR?: AcceptanceCriteriaRule
    criteriaS?: AcceptanceCriteriaScenario
    description?: string
    name: string
    nameAlias?: string
    requirement?: Reference<Requirement>
    tags: Array<Tag>
    type: TestType
}

export const AcceptanceCriteriaTest = 'AcceptanceCriteriaTest';

export function isAcceptanceCriteriaTest(item: unknown): item is AcceptanceCriteriaTest {
    return reflection.isInstance(item, AcceptanceCriteriaTest);
}

export interface ActionTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActionTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ActionTypeExtended = 'ActionTypeExtended';

export function isActionTypeExtended(item: unknown): item is ActionTypeExtended {
    return reflection.isInstance(item, ActionTypeExtended);
}

export interface ActionTypeExtendedRef extends AstNode {
    readonly $container: IfExpression | RefUCAction | UCActions;
    readonly $type: 'ActionTypeExtendedRef';
    type: Reference<ActionTypeExtended>
}

export const ActionTypeExtendedRef = 'ActionTypeExtendedRef';

export function isActionTypeExtendedRef(item: unknown): item is ActionTypeExtendedRef {
    return reflection.isInstance(item, ActionTypeExtendedRef);
}

export interface ActionTypeOriginal extends AstNode {
    readonly $container: IfExpression | RefUCAction | UCActions;
    readonly $type: 'ActionTypeOriginal';
    type: 'aCreate' | 'aDelete' | 'aRead' | 'aUpdate'
}

export const ActionTypeOriginal = 'ActionTypeOriginal';

export function isActionTypeOriginal(item: unknown): item is ActionTypeOriginal {
    return reflection.isInstance(item, ActionTypeOriginal);
}

export interface ActiveEvent extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActiveEvent';
    description?: string
    isFinal: boolean
    isInitial: boolean
    name: string
    nameAlias?: string
    stakeholder?: Reference<Stakeholder>
    tags: Array<Tag>
    type: ActiveEventType
}

export const ActiveEvent = 'ActiveEvent';

export function isActiveEvent(item: unknown): item is ActiveEvent {
    return reflection.isInstance(item, ActiveEvent);
}

export interface ActiveEventTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActiveEventTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ActiveEventTypeExtended = 'ActiveEventTypeExtended';

export function isActiveEventTypeExtended(item: unknown): item is ActiveEventTypeExtended {
    return reflection.isInstance(item, ActiveEventTypeExtended);
}

export interface ActiveEventTypeExtendedRef extends AstNode {
    readonly $container: ActiveEvent;
    readonly $type: 'ActiveEventTypeExtendedRef';
    type: Reference<ActiveEventTypeExtended>
}

export const ActiveEventTypeExtendedRef = 'ActiveEventTypeExtendedRef';

export function isActiveEventTypeExtendedRef(item: unknown): item is ActiveEventTypeExtendedRef {
    return reflection.isInstance(item, ActiveEventTypeExtendedRef);
}

export interface ActiveEventTypeOriginal extends AstNode {
    readonly $container: ActiveEvent;
    readonly $type: 'ActiveEventTypeOriginal';
    type: 'Cancel' | 'Conditional' | 'Error' | 'Receive' | 'Send' | 'Signal' | 'Terminate' | 'Timer' | 'Undefined'
}

export const ActiveEventTypeOriginal = 'ActiveEventTypeOriginal';

export function isActiveEventTypeOriginal(item: unknown): item is ActiveEventTypeOriginal {
    return reflection.isInstance(item, ActiveEventTypeOriginal);
}

export interface ActiveFlow extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActiveFlow';
    activeElements?: RefActiveElement
    condition?: string
    description?: string
    name: string
    nameAlias?: string
    tags: Array<Tag>
    type: ActiveFlowType
}

export const ActiveFlow = 'ActiveFlow';

export function isActiveFlow(item: unknown): item is ActiveFlow {
    return reflection.isInstance(item, ActiveFlow);
}

export interface ActiveFlowTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActiveFlowTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ActiveFlowTypeExtended = 'ActiveFlowTypeExtended';

export function isActiveFlowTypeExtended(item: unknown): item is ActiveFlowTypeExtended {
    return reflection.isInstance(item, ActiveFlowTypeExtended);
}

export interface ActiveFlowTypeExtendedRef extends AstNode {
    readonly $container: ActiveFlow;
    readonly $type: 'ActiveFlowTypeExtendedRef';
    type: Reference<ActiveFlowTypeExtended>
}

export const ActiveFlowTypeExtendedRef = 'ActiveFlowTypeExtendedRef';

export function isActiveFlowTypeExtendedRef(item: unknown): item is ActiveFlowTypeExtendedRef {
    return reflection.isInstance(item, ActiveFlowTypeExtendedRef);
}

export interface ActiveFlowTypeOriginal extends AstNode {
    readonly $container: ActiveFlow;
    readonly $type: 'ActiveFlowTypeOriginal';
    type: 'Parallel' | 'Sequence' | 'SequenceConditional'
}

export const ActiveFlowTypeOriginal = 'ActiveFlowTypeOriginal';

export function isActiveFlowTypeOriginal(item: unknown): item is ActiveFlowTypeOriginal {
    return reflection.isInstance(item, ActiveFlowTypeOriginal);
}

export interface ActiveTask extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActiveTask';
    description?: string
    name: string
    nameAlias?: string
    participant?: Reference<Stakeholder>
    participantTarget?: Reference<Stakeholder>
    partOf?: Reference<ActiveTask>
    tags: Array<Tag>
    type: ActiveTaskType
}

export const ActiveTask = 'ActiveTask';

export function isActiveTask(item: unknown): item is ActiveTask {
    return reflection.isInstance(item, ActiveTask);
}

export interface ActiveTaskTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActiveTaskTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ActiveTaskTypeExtended = 'ActiveTaskTypeExtended';

export function isActiveTaskTypeExtended(item: unknown): item is ActiveTaskTypeExtended {
    return reflection.isInstance(item, ActiveTaskTypeExtended);
}

export interface ActiveTaskTypeExtendedRef extends AstNode {
    readonly $container: ActiveTask;
    readonly $type: 'ActiveTaskTypeExtendedRef';
    type: Reference<ActiveTaskTypeExtended>
}

export const ActiveTaskTypeExtendedRef = 'ActiveTaskTypeExtendedRef';

export function isActiveTaskTypeExtendedRef(item: unknown): item is ActiveTaskTypeExtendedRef {
    return reflection.isInstance(item, ActiveTaskTypeExtendedRef);
}

export interface ActiveTaskTypeOriginal extends AstNode {
    readonly $container: ActiveTask;
    readonly $type: 'ActiveTaskTypeOriginal';
    type: 'BusinessRule' | 'Manual' | 'Receive' | 'Script' | 'Send' | 'Service' | 'Undefined' | 'User'
}

export const ActiveTaskTypeOriginal = 'ActiveTaskTypeOriginal';

export function isActiveTaskTypeOriginal(item: unknown): item is ActiveTaskTypeOriginal {
    return reflection.isInstance(item, ActiveTaskTypeOriginal);
}

export interface Actor extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Actor';
    description?: string
    name: string
    nameAlias?: string
    stakeholder?: Reference<Stakeholder>
    super?: Reference<Actor>
    tags: Array<Tag>
    type: ActorType
}

export const Actor = 'Actor';

export function isActor(item: unknown): item is Actor {
    return reflection.isInstance(item, Actor);
}

export interface ActorTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ActorTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ActorTypeExtended = 'ActorTypeExtended';

export function isActorTypeExtended(item: unknown): item is ActorTypeExtended {
    return reflection.isInstance(item, ActorTypeExtended);
}

export interface ActorTypeExtendedRef extends AstNode {
    readonly $container: Actor;
    readonly $type: 'ActorTypeExtendedRef';
    type: Reference<ActorTypeExtended>
}

export const ActorTypeExtendedRef = 'ActorTypeExtendedRef';

export function isActorTypeExtendedRef(item: unknown): item is ActorTypeExtendedRef {
    return reflection.isInstance(item, ActorTypeExtendedRef);
}

export interface ActorTypeOriginal extends AstNode {
    readonly $container: Actor;
    readonly $type: 'ActorTypeOriginal';
    type: 'ExternalSystem' | 'Other' | 'User'
}

export const ActorTypeOriginal = 'ActorTypeOriginal';

export function isActorTypeOriginal(item: unknown): item is ActorTypeOriginal {
    return reflection.isInstance(item, ActorTypeOriginal);
}

export interface AttributeValue extends AstNode {
    readonly $container: DataAttributeTableRow | _Date;
    readonly $type: 'AttributeValue' | 'Month' | '_Date';
    value: string
}

export const AttributeValue = 'AttributeValue';

export function isAttributeValue(item: unknown): item is AttributeValue {
    return reflection.isInstance(item, AttributeValue);
}

export interface Check extends AstNode {
    readonly $container: DataAttributeConstraint | DataEntityConstraint;
    readonly $type: 'Check';
    checkExpression: string
    name: string
}

export const Check = 'Check';

export function isCheck(item: unknown): item is Check {
    return reflection.isInstance(item, Check);
}

export interface CheckTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'CheckTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const CheckTypeExtended = 'CheckTypeExtended';

export function isCheckTypeExtended(item: unknown): item is CheckTypeExtended {
    return reflection.isInstance(item, CheckTypeExtended);
}

export interface CheckTypeExtendedRef extends AstNode {
    readonly $container: TestCheck;
    readonly $type: 'CheckTypeExtendedRef';
    type: Reference<CheckTypeExtended>
}

export const CheckTypeExtendedRef = 'CheckTypeExtendedRef';

export function isCheckTypeExtendedRef(item: unknown): item is CheckTypeExtendedRef {
    return reflection.isInstance(item, CheckTypeExtendedRef);
}

export interface CheckTypeOriginal extends AstNode {
    readonly $container: TestCheck;
    readonly $type: 'CheckTypeOriginal';
    type: 'ElementOnScreen' | 'None' | 'Other' | 'ResponseTime' | 'Screen' | 'Script' | 'TextOnElement' | 'TextOnScreen' | 'VariableValue'
}

export const CheckTypeOriginal = 'CheckTypeOriginal';

export function isCheckTypeOriginal(item: unknown): item is CheckTypeOriginal {
    return reflection.isInstance(item, CheckTypeOriginal);
}

export interface ChildDataEntity extends AstNode {
    readonly $container: DataEntityCluster;
    readonly $type: 'ChildDataEntity';
    child: Reference<DataEntity>
    childUses?: RefDataEntity
}

export const ChildDataEntity = 'ChildDataEntity';

export function isChildDataEntity(item: unknown): item is ChildDataEntity {
    return reflection.isInstance(item, ChildDataEntity);
}

export interface Constraint extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Constraint';
    acceptanceCriteria: Array<AcceptanceCriteria>
    description?: string
    isAbstract: boolean
    isConcrete: boolean
    isNegative: boolean
    isPositive: boolean
    isProblem: boolean
    isSolution: boolean
    name: string
    nameAlias?: string
    partOf?: Reference<Constraint>
    priority?: PriorityType
    stakeholder?: Reference<Stakeholder>
    subType?: ConstraintSubType
    tags: Array<Tag>
    type: ConstraintType
}

export const Constraint = 'Constraint';

export function isConstraint(item: unknown): item is Constraint {
    return reflection.isInstance(item, Constraint);
}

export interface ConstraintSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ConstraintSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ConstraintSubTypeExtended = 'ConstraintSubTypeExtended';

export function isConstraintSubTypeExtended(item: unknown): item is ConstraintSubTypeExtended {
    return reflection.isInstance(item, ConstraintSubTypeExtended);
}

export interface ConstraintSubTypeExtendedRef extends AstNode {
    readonly $container: Constraint;
    readonly $type: 'ConstraintSubTypeExtendedRef';
    type: Reference<ConstraintSubTypeExtended>
}

export const ConstraintSubTypeExtendedRef = 'ConstraintSubTypeExtendedRef';

export function isConstraintSubTypeExtendedRef(item: unknown): item is ConstraintSubTypeExtendedRef {
    return reflection.isInstance(item, ConstraintSubTypeExtendedRef);
}

export interface ConstraintSubTypeOriginal extends AstNode {
    readonly $container: Constraint;
    readonly $type: 'ConstraintSubTypeOriginal';
    type: 'Cultural_Currency' | 'Cultural_Language' | 'Cultural_Other' | 'Legal_International' | 'Legal_National' | 'Legal_Other' | 'Organizational_Management' | 'Organizational_Other' | 'Organizational_Politics' | 'Other' | 'Physical_Abstract' | 'Physical_Concrete' | 'Project_Cost' | 'Project_Other' | 'Project_Quality' | 'Project_Risk' | 'Project_Scope' | 'Project_Time' | 'Technological_DevelopmentTool' | 'Technological_PlatformHardware' | 'Technological_PlatformSoftware'
}

export const ConstraintSubTypeOriginal = 'ConstraintSubTypeOriginal';

export function isConstraintSubTypeOriginal(item: unknown): item is ConstraintSubTypeOriginal {
    return reflection.isInstance(item, ConstraintSubTypeOriginal);
}

export interface ConstraintTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ConstraintTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ConstraintTypeExtended = 'ConstraintTypeExtended';

export function isConstraintTypeExtended(item: unknown): item is ConstraintTypeExtended {
    return reflection.isInstance(item, ConstraintTypeExtended);
}

export interface ConstraintTypeExtendedRef extends AstNode {
    readonly $container: Constraint;
    readonly $type: 'ConstraintTypeExtendedRef';
    type: Reference<ConstraintTypeExtended>
}

export const ConstraintTypeExtendedRef = 'ConstraintTypeExtendedRef';

export function isConstraintTypeExtendedRef(item: unknown): item is ConstraintTypeExtendedRef {
    return reflection.isInstance(item, ConstraintTypeExtendedRef);
}

export interface ConstraintTypeOriginal extends AstNode {
    readonly $container: Constraint;
    readonly $type: 'ConstraintTypeOriginal';
    type: 'Cultural' | 'Legal' | 'Organizational' | 'Other' | 'Physical' | 'Project' | 'Technological'
}

export const ConstraintTypeOriginal = 'ConstraintTypeOriginal';

export function isConstraintTypeOriginal(item: unknown): item is ConstraintTypeOriginal {
    return reflection.isInstance(item, ConstraintTypeOriginal);
}

export interface Data extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Data';
    description?: string
    name: string
    nameAlias?: string
    table?: DataAttributeValues
    tags: Array<Tag>
    type: Reference<DataEntityGeneric>
}

export const Data = 'Data';

export function isData(item: unknown): item is Data {
    return reflection.isInstance(item, Data);
}

export interface DataAttribute extends AstNode {
    readonly $container: DataEntity | TestVariable;
    readonly $type: 'DataAttribute';
    constraint?: DataAttributeConstraint
    defaultValue?: string
    description?: string
    helpMessage?: string
    name: string
    nameAlias?: string
    tags: Array<Tag>
    type: DataAttributeType
    values?: string
    visualizatione?: string
}

export const DataAttribute = 'DataAttribute';

export function isDataAttribute(item: unknown): item is DataAttribute {
    return reflection.isInstance(item, DataAttribute);
}

export interface DataAttributeConstraint extends AstNode {
    readonly $container: DataAttribute;
    readonly $type: 'DataAttributeConstraint';
    checks: Array<Check>
    expression?: string
    foreignKey?: ForeignKey
    isDerived?: 'Derived'
    isEncrypted?: 'Encrypted'
    isNotNull?: 'NotNull'
    isNotVisible?: 'NotVisible'
    isPrimaryKey?: 'PrimaryKey'
    isReadOnly?: 'ReadOnly'
    isUnique?: 'Unique'
    manyToMany?: ManyToMany
    multiplicity?: Multiplicity
}

export const DataAttributeConstraint = 'DataAttributeConstraint';

export function isDataAttributeConstraint(item: unknown): item is DataAttributeConstraint {
    return reflection.isInstance(item, DataAttributeConstraint);
}

export interface DataAttributeRefs extends AstNode {
    readonly $container: DataAttributeValues;
    readonly $type: 'DataAttributeRefs';
    attributeRef: Array<Reference<DataAttribute>>
}

export const DataAttributeRefs = 'DataAttributeRefs';

export function isDataAttributeRefs(item: unknown): item is DataAttributeRefs {
    return reflection.isInstance(item, DataAttributeRefs);
}

export interface DataAttributeRefsList extends AstNode {
    readonly $type: 'DataAttributeRefsList';
    attributeRef: Array<Reference<DataAttribute>>
}

export const DataAttributeRefsList = 'DataAttributeRefsList';

export function isDataAttributeRefsList(item: unknown): item is DataAttributeRefsList {
    return reflection.isInstance(item, DataAttributeRefsList);
}

export interface DataAttributeTableRow extends AstNode {
    readonly $container: DataAttributeValues;
    readonly $type: 'DataAttributeTableRow';
    attributeValues: Array<AttributeValue>
}

export const DataAttributeTableRow = 'DataAttributeTableRow';

export function isDataAttributeTableRow(item: unknown): item is DataAttributeTableRow {
    return reflection.isInstance(item, DataAttributeTableRow);
}

export interface DataAttributeType extends AstNode {
    readonly $container: DataAttribute | TestDataAttribute;
    readonly $type: 'DataAttributeType' | 'DataAttributeTypeExtendedRef' | 'DataAttributeTypeOriginal' | 'DataEnumerationRef';
    size: DoubleOrInt
}

export const DataAttributeType = 'DataAttributeType';

export function isDataAttributeType(item: unknown): item is DataAttributeType {
    return reflection.isInstance(item, DataAttributeType);
}

export interface DataAttributeTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataAttributeTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const DataAttributeTypeExtended = 'DataAttributeTypeExtended';

export function isDataAttributeTypeExtended(item: unknown): item is DataAttributeTypeExtended {
    return reflection.isInstance(item, DataAttributeTypeExtended);
}

export interface DataAttributeValues extends AstNode {
    readonly $container: Data | DataEntityTest | TestScenario;
    readonly $type: 'DataAttributeValues';
    tableHeader: DataAttributeRefs
    tableRows: Array<DataAttributeTableRow>
}

export const DataAttributeValues = 'DataAttributeValues';

export function isDataAttributeValues(item: unknown): item is DataAttributeValues {
    return reflection.isInstance(item, DataAttributeValues);
}

export interface DataEntity extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataEntity';
    attributes: Array<DataAttribute>
    constraint?: DataEntityConstraint
    description?: string
    name: string
    nameAlias?: string
    subType?: DataEntitySubType
    super?: Reference<DataEntity>
    tags: Array<Tag>
    type: DataEntityType
}

export const DataEntity = 'DataEntity';

export function isDataEntity(item: unknown): item is DataEntity {
    return reflection.isInstance(item, DataEntity);
}

export interface DataEntityCluster extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataEntityCluster';
    children: Array<ChildDataEntity>
    description?: string
    main?: Reference<DataEntity>
    name: string
    nameAlias?: string
    tags: Array<Tag>
    type: DataEntityClusterType
    uses?: RefDataEntity
}

export const DataEntityCluster = 'DataEntityCluster';

export function isDataEntityCluster(item: unknown): item is DataEntityCluster {
    return reflection.isInstance(item, DataEntityCluster);
}

export interface DataEntityClusterTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataEntityClusterTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const DataEntityClusterTypeExtended = 'DataEntityClusterTypeExtended';

export function isDataEntityClusterTypeExtended(item: unknown): item is DataEntityClusterTypeExtended {
    return reflection.isInstance(item, DataEntityClusterTypeExtended);
}

export interface DataEntityClusterTypeExtendedRef extends AstNode {
    readonly $container: DataEntityCluster;
    readonly $type: 'DataEntityClusterTypeExtendedRef';
    type: Reference<DataEntityClusterTypeExtended>
}

export const DataEntityClusterTypeExtendedRef = 'DataEntityClusterTypeExtendedRef';

export function isDataEntityClusterTypeExtendedRef(item: unknown): item is DataEntityClusterTypeExtendedRef {
    return reflection.isInstance(item, DataEntityClusterTypeExtendedRef);
}

export interface DataEntityClusterTypeOriginal extends AstNode {
    readonly $container: DataEntityCluster;
    readonly $type: 'DataEntityClusterTypeOriginal';
    type: 'Document' | 'Master' | 'Other' | 'Parameter' | 'Reference' | 'Transaction'
}

export const DataEntityClusterTypeOriginal = 'DataEntityClusterTypeOriginal';

export function isDataEntityClusterTypeOriginal(item: unknown): item is DataEntityClusterTypeOriginal {
    return reflection.isInstance(item, DataEntityClusterTypeOriginal);
}

export interface DataEntityConstraint extends AstNode {
    readonly $container: DataEntity;
    readonly $type: 'DataEntityConstraint';
    checks: Array<Check>
    isEncrypted?: 'Encrypted'
    isReadOnly?: 'ReadOnly'
    showAsAttribute?: Reference<DataAttribute>
}

export const DataEntityConstraint = 'DataEntityConstraint';

export function isDataEntityConstraint(item: unknown): item is DataEntityConstraint {
    return reflection.isInstance(item, DataEntityConstraint);
}

export interface DataEntitySubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataEntitySubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const DataEntitySubTypeExtended = 'DataEntitySubTypeExtended';

export function isDataEntitySubTypeExtended(item: unknown): item is DataEntitySubTypeExtended {
    return reflection.isInstance(item, DataEntitySubTypeExtended);
}

export interface DataEntitySubTypeExtendedRef extends AstNode {
    readonly $container: DataEntity;
    readonly $type: 'DataEntitySubTypeExtendedRef';
    type: Reference<DataEntitySubTypeExtended>
}

export const DataEntitySubTypeExtendedRef = 'DataEntitySubTypeExtendedRef';

export function isDataEntitySubTypeExtendedRef(item: unknown): item is DataEntitySubTypeExtendedRef {
    return reflection.isInstance(item, DataEntitySubTypeExtendedRef);
}

export interface DataEntitySubTypeOriginal extends AstNode {
    readonly $container: DataEntity;
    readonly $type: 'DataEntitySubTypeOriginal';
    type: 'Other' | 'Regular' | 'Weak'
}

export const DataEntitySubTypeOriginal = 'DataEntitySubTypeOriginal';

export function isDataEntitySubTypeOriginal(item: unknown): item is DataEntitySubTypeOriginal {
    return reflection.isInstance(item, DataEntitySubTypeOriginal);
}

export interface DataEntityTest extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataEntityTest';
    description?: string
    entity?: Reference<DataEntity>
    message?: string
    name: string
    nameAlias?: string
    table?: DataAttributeValues
    tags: Array<Tag>
    testDataAttributes: Array<TestDataAttribute>
    type: TestType
}

export const DataEntityTest = 'DataEntityTest';

export function isDataEntityTest(item: unknown): item is DataEntityTest {
    return reflection.isInstance(item, DataEntityTest);
}

export interface DataEntityTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataEntityTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const DataEntityTypeExtended = 'DataEntityTypeExtended';

export function isDataEntityTypeExtended(item: unknown): item is DataEntityTypeExtended {
    return reflection.isInstance(item, DataEntityTypeExtended);
}

export interface DataEntityTypeExtendedRef extends AstNode {
    readonly $container: DataEntity;
    readonly $type: 'DataEntityTypeExtendedRef';
    type: Reference<DataEntityTypeExtended>
}

export const DataEntityTypeExtendedRef = 'DataEntityTypeExtendedRef';

export function isDataEntityTypeExtendedRef(item: unknown): item is DataEntityTypeExtendedRef {
    return reflection.isInstance(item, DataEntityTypeExtendedRef);
}

export interface DataEntityTypeOriginal extends AstNode {
    readonly $container: DataEntity;
    readonly $type: 'DataEntityTypeOriginal';
    type: 'Document' | 'Master' | 'Other' | 'Parameter' | 'Reference' | 'Transaction'
}

export const DataEntityTypeOriginal = 'DataEntityTypeOriginal';

export function isDataEntityTypeOriginal(item: unknown): item is DataEntityTypeOriginal {
    return reflection.isInstance(item, DataEntityTypeOriginal);
}

export interface DataEnumeration extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'DataEnumeration';
    description?: string
    name: string
    nameAlias?: string
    tags: Array<Tag>
    values: Array<string>
}

export const DataEnumeration = 'DataEnumeration';

export function isDataEnumeration(item: unknown): item is DataEnumeration {
    return reflection.isInstance(item, DataEnumeration);
}

export interface DataVariableRefs extends AstNode {
    readonly $container: DataVariableValues;
    readonly $type: 'DataVariableRefs';
    variableRef: Array<Reference<DataAttribute>>
}

export const DataVariableRefs = 'DataVariableRefs';

export function isDataVariableRefs(item: unknown): item is DataVariableRefs {
    return reflection.isInstance(item, DataVariableRefs);
}

export interface DataVariableTableRow extends AstNode {
    readonly $container: DataVariableValues;
    readonly $type: 'DataVariableTableRow';
    variableValues: Array<string>
}

export const DataVariableTableRow = 'DataVariableTableRow';

export function isDataVariableTableRow(item: unknown): item is DataVariableTableRow {
    return reflection.isInstance(item, DataVariableTableRow);
}

export interface DataVariableValues extends AstNode {
    readonly $container: TestScenario;
    readonly $type: 'DataVariableValues';
    tableHeader: DataVariableRefs
    tableRows: Array<DataVariableTableRow>
}

export const DataVariableValues = 'DataVariableValues';

export function isDataVariableValues(item: unknown): item is DataVariableValues {
    return reflection.isInstance(item, DataVariableValues);
}

export interface ElementsRelation extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ElementsRelation';
    description?: string
    name: string
    nameAlias?: string
    source?: Reference<SystemElement>
    tags: Array<Tag>
    target?: Reference<SystemElement>
    type: ElementsRelationType
}

export const ElementsRelation = 'ElementsRelation';

export function isElementsRelation(item: unknown): item is ElementsRelation {
    return reflection.isInstance(item, ElementsRelation);
}

export interface ElementsRelationType extends AstNode {
    readonly $container: ElementsRelation;
    readonly $type: 'ElementsRelationType';
    type: 'Conflicts' | 'Identical' | 'Obstructs' | 'Other' | 'Relates' | 'Requires' | 'Supports'
}

export const ElementsRelationType = 'ElementsRelationType';

export function isElementsRelationType(item: unknown): item is ElementsRelationType {
    return reflection.isInstance(item, ElementsRelationType);
}

export interface Expression extends AstNode {
    readonly $container: QR;
    readonly $type: 'Expression';
    metric: MetricType
    operator: ExpressionOperator
    value: number
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface ExpressionOperator extends AstNode {
    readonly $container: Expression;
    readonly $type: 'ExpressionOperator';
    value: '<' | '<=' | '<>' | '=' | '>' | '>='
}

export const ExpressionOperator = 'ExpressionOperator';

export function isExpressionOperator(item: unknown): item is ExpressionOperator {
    return reflection.isInstance(item, ExpressionOperator);
}

export interface ForeignKey extends AstNode {
    readonly $container: DataAttributeConstraint;
    readonly $type: 'ForeignKey';
    defaultValue?: string
    onDelete?: ForeignKeyOnDeleteType
    showAsField?: Reference<DataAttribute>
    targetEntity: Reference<DataEntity>
    toField?: Reference<DataAttribute>
}

export const ForeignKey = 'ForeignKey';

export function isForeignKey(item: unknown): item is ForeignKey {
    return reflection.isInstance(item, ForeignKey);
}

export interface ForeignKeyOnDeleteTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ForeignKeyOnDeleteTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ForeignKeyOnDeleteTypeExtended = 'ForeignKeyOnDeleteTypeExtended';

export function isForeignKeyOnDeleteTypeExtended(item: unknown): item is ForeignKeyOnDeleteTypeExtended {
    return reflection.isInstance(item, ForeignKeyOnDeleteTypeExtended);
}

export interface ForeignKeyOnDeleteTypeExtendedRef extends AstNode {
    readonly $container: ForeignKey;
    readonly $type: 'ForeignKeyOnDeleteTypeExtendedRef';
    type: Reference<ForeignKeyOnDeleteTypeExtended>
}

export const ForeignKeyOnDeleteTypeExtendedRef = 'ForeignKeyOnDeleteTypeExtendedRef';

export function isForeignKeyOnDeleteTypeExtendedRef(item: unknown): item is ForeignKeyOnDeleteTypeExtendedRef {
    return reflection.isInstance(item, ForeignKeyOnDeleteTypeExtendedRef);
}

export interface ForeignKeyOnDeleteTypeOriginal extends AstNode {
    readonly $container: ForeignKey;
    readonly $type: 'ForeignKeyOnDeleteTypeOriginal';
    type: 'CASCADE' | 'PROTECT' | 'SET_DEFAULT' | 'SET_NULL'
}

export const ForeignKeyOnDeleteTypeOriginal = 'ForeignKeyOnDeleteTypeOriginal';

export function isForeignKeyOnDeleteTypeOriginal(item: unknown): item is ForeignKeyOnDeleteTypeOriginal {
    return reflection.isInstance(item, ForeignKeyOnDeleteTypeOriginal);
}

export interface FR extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'FR';
    acceptanceCriteria: Array<AcceptanceCriteria>
    description?: string
    isAbstract: boolean
    isConcrete: boolean
    isNegative: boolean
    isPositive: boolean
    isProblem: boolean
    isSolution: boolean
    name: string
    nameAlias?: string
    partOf?: Reference<FR>
    priority?: PriorityType
    stakeholder?: Reference<Stakeholder>
    tags: Array<Tag>
    type: FRType
}

export const FR = 'FR';

export function isFR(item: unknown): item is FR {
    return reflection.isInstance(item, FR);
}

export interface FRTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'FRTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const FRTypeExtended = 'FRTypeExtended';

export function isFRTypeExtended(item: unknown): item is FRTypeExtended {
    return reflection.isInstance(item, FRTypeExtended);
}

export interface FRTypeExtendedRef extends AstNode {
    readonly $container: FR;
    readonly $type: 'FRTypeExtendedRef';
    type: Reference<FRTypeExtended>
}

export const FRTypeExtendedRef = 'FRTypeExtendedRef';

export function isFRTypeExtendedRef(item: unknown): item is FRTypeExtendedRef {
    return reflection.isInstance(item, FRTypeExtendedRef);
}

export interface FRTypeOriginal extends AstNode {
    readonly $container: FR;
    readonly $type: 'FRTypeOriginal';
    type: 'Behavioral' | 'Data' | 'Functional'
}

export const FRTypeOriginal = 'FRTypeOriginal';

export function isFRTypeOriginal(item: unknown): item is FRTypeOriginal {
    return reflection.isInstance(item, FRTypeOriginal);
}

export interface GlossaryTerm extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'GlossaryTerm';
    acronym?: string
    applicableTo?: RefTermApplicableTo
    description?: string
    name: string
    nameAlias?: string
    partOf?: Reference<GlossaryTerm>
    super?: Reference<GlossaryTerm>
    synonym?: string
    tags: Array<Tag>
    type: GlossaryTermType
}

export const GlossaryTerm = 'GlossaryTerm';

export function isGlossaryTerm(item: unknown): item is GlossaryTerm {
    return reflection.isInstance(item, GlossaryTerm);
}

export interface GlossaryTermTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'GlossaryTermTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const GlossaryTermTypeExtended = 'GlossaryTermTypeExtended';

export function isGlossaryTermTypeExtended(item: unknown): item is GlossaryTermTypeExtended {
    return reflection.isInstance(item, GlossaryTermTypeExtended);
}

export interface GlossaryTermTypeExtendedRef extends AstNode {
    readonly $container: GlossaryTerm;
    readonly $type: 'GlossaryTermTypeExtendedRef';
    type: Reference<GlossaryTermTypeExtended>
}

export const GlossaryTermTypeExtendedRef = 'GlossaryTermTypeExtendedRef';

export function isGlossaryTermTypeExtendedRef(item: unknown): item is GlossaryTermTypeExtendedRef {
    return reflection.isInstance(item, GlossaryTermTypeExtendedRef);
}

export interface GlossaryTermTypeOriginal extends AstNode {
    readonly $container: GlossaryTerm;
    readonly $type: 'GlossaryTermTypeOriginal';
    type: 'Adjective' | 'Adverb' | 'Noun' | 'Verb'
}

export const GlossaryTermTypeOriginal = 'GlossaryTermTypeOriginal';

export function isGlossaryTermTypeOriginal(item: unknown): item is GlossaryTermTypeOriginal {
    return reflection.isInstance(item, GlossaryTermTypeOriginal);
}

export interface Goal extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Goal';
    acceptanceCriteria: Array<AcceptanceCriteria>
    description?: string
    isAbstract: boolean
    isConcrete: boolean
    isNegative: boolean
    isPositive: boolean
    isProblem: boolean
    isSolution: boolean
    name: string
    nameAlias?: string
    partOf?: Reference<Goal>
    priority?: PriorityType
    stakeholder?: Reference<Stakeholder>
    subType?: GoalSubType
    tags: Array<Tag>
    type: GoalType
}

export const Goal = 'Goal';

export function isGoal(item: unknown): item is Goal {
    return reflection.isInstance(item, Goal);
}

export interface GoalSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'GoalSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const GoalSubTypeExtended = 'GoalSubTypeExtended';

export function isGoalSubTypeExtended(item: unknown): item is GoalSubTypeExtended {
    return reflection.isInstance(item, GoalSubTypeExtended);
}

export interface GoalSubTypeExtendedRef extends AstNode {
    readonly $container: Goal;
    readonly $type: 'GoalSubTypeExtendedRef';
    type: Reference<GoalSubTypeExtended>
}

export const GoalSubTypeExtendedRef = 'GoalSubTypeExtendedRef';

export function isGoalSubTypeExtendedRef(item: unknown): item is GoalSubTypeExtendedRef {
    return reflection.isInstance(item, GoalSubTypeExtendedRef);
}

export interface GoalSubTypeOriginal extends AstNode {
    readonly $container: Goal;
    readonly $type: 'GoalSubTypeOriginal';
    type: 'Compatibility_CoExistence' | 'Compatibility_Interoperability' | 'Compatibility_Other' | 'Cultural_Currency' | 'Cultural_Language' | 'Cultural_Other' | 'Legal_International' | 'Legal_National' | 'Legal_Other' | 'Maintainability_Analyzability' | 'Maintainability_Modifiability' | 'Maintainability_Modularity' | 'Maintainability_Other' | 'Maintainability_Reusability' | 'Maintainability_Testability' | 'Performance_DiskCapacity' | 'Performance_MemoryCapacity' | 'Performance_NetworkResponseTime' | 'Performance_Other' | 'Performance_SystemResponseTime' | 'Portability_Adaptability' | 'Portability_Installability' | 'Portability_Other' | 'Portability_Replaceability' | 'Privacy_Collection' | 'Privacy_Disclosure' | 'Privacy_Informative' | 'Privacy_Other' | 'Privacy_Retention' | 'Privacy_Usage' | 'Reliability_Availability' | 'Reliability_FaultTolerance' | 'Reliability_Maturity' | 'Reliability_Other' | 'Reliability_Recoverability' | 'Security_Accountability' | 'Security_Authentication' | 'Security_Authorization' | 'Security_Confidentiality' | 'Security_Integrity' | 'Security_NonRepudiation' | 'Security_Other' | 'Security_PhysicalProtection' | 'Security_Recovery' | 'Usability_AappropriatenessRecognizability' | 'Usability_Accessibility' | 'Usability_Learnability' | 'Usability_Operability' | 'Usability_Other' | 'Usability_UserErrorProtection' | 'Usability_UserInterfaceAesthetics'
}

export const GoalSubTypeOriginal = 'GoalSubTypeOriginal';

export function isGoalSubTypeOriginal(item: unknown): item is GoalSubTypeOriginal {
    return reflection.isInstance(item, GoalSubTypeOriginal);
}

export interface GoalTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'GoalTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const GoalTypeExtended = 'GoalTypeExtended';

export function isGoalTypeExtended(item: unknown): item is GoalTypeExtended {
    return reflection.isInstance(item, GoalTypeExtended);
}

export interface GoalTypeExtendedRef extends AstNode {
    readonly $container: Goal;
    readonly $type: 'GoalTypeExtendedRef';
    type: Reference<GoalTypeExtended>
}

export const GoalTypeExtendedRef = 'GoalTypeExtendedRef';

export function isGoalTypeExtendedRef(item: unknown): item is GoalTypeExtendedRef {
    return reflection.isInstance(item, GoalTypeExtendedRef);
}

export interface GoalTypeOriginal extends AstNode {
    readonly $container: Goal;
    readonly $type: 'GoalTypeOriginal';
    type: 'Compatibility' | 'Cultural' | 'Functional' | 'Legal' | 'Maintainability' | 'Other' | 'Performance' | 'Portability' | 'Privacy' | 'Reliability' | 'Security' | 'Usability'
}

export const GoalTypeOriginal = 'GoalTypeOriginal';

export function isGoalTypeOriginal(item: unknown): item is GoalTypeOriginal {
    return reflection.isInstance(item, GoalTypeOriginal);
}

export interface IfExpression extends AstNode {
    readonly $type: 'IfExpression';
    action?: ActionType
    condition?: string
}

export const IfExpression = 'IfExpression';

export function isIfExpression(item: unknown): item is IfExpression {
    return reflection.isInstance(item, IfExpression);
}

export interface ImpactLevel extends AstNode {
    readonly $container: RiskAssessment;
    readonly $type: 'ImpactLevel';
    type: 'High' | 'Low' | 'Medium' | 'VeryHigh' | 'VeryLow'
}

export const ImpactLevel = 'ImpactLevel';

export function isImpactLevel(item: unknown): item is ImpactLevel {
    return reflection.isInstance(item, ImpactLevel);
}

export interface Import extends AstNode {
    readonly $container: PackageSystem;
    readonly $type: 'Import';
    importedNamespace: QualifiedNameWithWildcard
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface IncludeAll extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'IncludeAll';
    description?: string
    system: Reference<System>
    tags: Array<Tag>
}

export const IncludeAll = 'IncludeAll';

export function isIncludeAll(item: unknown): item is IncludeAll {
    return reflection.isInstance(item, IncludeAll);
}

export interface IncludeElement extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'IncludeElement';
    description?: string
    element: Reference<SystemElement>
    system: Reference<System>
    tags: Array<Tag>
    type: IncludeSystemElementType
    updateFields?: UpdateFields
}

export const IncludeElement = 'IncludeElement';

export function isIncludeElement(item: unknown): item is IncludeElement {
    return reflection.isInstance(item, IncludeElement);
}

export interface IncludeSystemElementType extends AstNode {
    readonly $container: IncludeElement;
    readonly $type: 'IncludeSystemElementType';
    type: 'AcceptanceCriteriaTestView' | 'ActiveEvent' | 'ActiveFlow' | 'ActiveTask' | 'Actor' | 'Constraint' | 'DataEntity' | 'DataEntityCluster' | 'DataEntityTestView' | 'DataEnumeration' | 'FR' | 'GlossaryTerm' | 'Goal' | 'QR' | 'Risk' | 'Stakeholder' | 'StateMachine' | 'StatemachineTestView' | 'UseCase' | 'UseCaseTestView' | 'UserStory' | 'Vulnerability'
}

export const IncludeSystemElementType = 'IncludeSystemElementType';

export function isIncludeSystemElementType(item: unknown): item is IncludeSystemElementType {
    return reflection.isInstance(item, IncludeSystemElementType);
}

export interface MainScenario extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'MainScenario';
    description?: string
    name: string
    nameAlias?: string
    steps: Array<Step>
}

export const MainScenario = 'MainScenario';

export function isMainScenario(item: unknown): item is MainScenario {
    return reflection.isInstance(item, MainScenario);
}

export interface ManyToMany extends AstNode {
    readonly $container: DataAttributeConstraint;
    readonly $type: 'ManyToMany';
    targetEntity: Reference<DataEntity>
    throughEntity?: Reference<DataEntity>
    throughSourceField?: Reference<DataAttribute>
    throughTargetField?: Reference<DataAttribute>
}

export const ManyToMany = 'ManyToMany';

export function isManyToMany(item: unknown): item is ManyToMany {
    return reflection.isInstance(item, ManyToMany);
}

export interface MetricTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'MetricTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const MetricTypeExtended = 'MetricTypeExtended';

export function isMetricTypeExtended(item: unknown): item is MetricTypeExtended {
    return reflection.isInstance(item, MetricTypeExtended);
}

export interface MetricTypeExtendedRef extends AstNode {
    readonly $container: Expression | TestCheck;
    readonly $type: 'MetricTypeExtendedRef';
    type: Reference<MetricTypeExtended>
}

export const MetricTypeExtendedRef = 'MetricTypeExtendedRef';

export function isMetricTypeExtendedRef(item: unknown): item is MetricTypeExtendedRef {
    return reflection.isInstance(item, MetricTypeExtendedRef);
}

export interface MetricTypeOriginal extends AstNode {
    readonly $container: Expression | TestCheck;
    readonly $type: 'MetricTypeOriginal';
    type: 'Capacity_EByte' | 'Capacity_GByte' | 'Capacity_KByte' | 'Capacity_MByte' | 'Capacity_PByte' | 'Capacity_TByte' | 'Click' | 'Error' | 'Error_PerTask' | 'Frequency_Hz' | 'Frequency_KHz' | 'Frequency_MHz' | 'Other' | 'Range_Binary' | 'Range_LikertScale' | 'Range_Other' | 'Task' | 'Time_Day' | 'Time_Hour' | 'Time_Min' | 'Time_Sec' | 'Time_mSec'
}

export const MetricTypeOriginal = 'MetricTypeOriginal';

export function isMetricTypeOriginal(item: unknown): item is MetricTypeOriginal {
    return reflection.isInstance(item, MetricTypeOriginal);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    packages: Array<PackageAbstract>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Multiplicity extends AstNode {
    readonly $container: DataAttributeConstraint;
    readonly $type: 'Multiplicity';
    type: '"*"' | '"0"' | '"0..1"' | '"1"' | string
}

export const Multiplicity = 'Multiplicity';

export function isMultiplicity(item: unknown): item is Multiplicity {
    return reflection.isInstance(item, Multiplicity);
}

export interface OperationExtension extends AstNode {
    readonly $container: TestStep;
    readonly $type: 'OperationExtension';
    check?: TestCheck
    subSubType: StepSubSubType
    target?: TestOperationTarget
}

export const OperationExtension = 'OperationExtension';

export function isOperationExtension(item: unknown): item is OperationExtension {
    return reflection.isInstance(item, OperationExtension);
}

export interface PackageSystem extends AstNode {
    readonly $container: Model;
    readonly $type: 'PackageSystem';
    imports: Array<Import>
    name: QualifiedName
    system: System
}

export const PackageSystem = 'PackageSystem';

export function isPackageSystem(item: unknown): item is PackageSystem {
    return reflection.isInstance(item, PackageSystem);
}

export interface PriorityTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'PriorityTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const PriorityTypeExtended = 'PriorityTypeExtended';

export function isPriorityTypeExtended(item: unknown): item is PriorityTypeExtended {
    return reflection.isInstance(item, PriorityTypeExtended);
}

export interface PriorityTypeExtendedRef extends AstNode {
    readonly $container: Constraint | FR | Goal | QR | UseCase | UserStory;
    readonly $type: 'PriorityTypeExtendedRef';
    type: Reference<PriorityTypeExtended>
}

export const PriorityTypeExtendedRef = 'PriorityTypeExtendedRef';

export function isPriorityTypeExtendedRef(item: unknown): item is PriorityTypeExtendedRef {
    return reflection.isInstance(item, PriorityTypeExtendedRef);
}

export interface PriorityTypeOriginal extends AstNode {
    readonly $container: Constraint | FR | Goal | QR | UseCase | UserStory;
    readonly $type: 'PriorityTypeOriginal';
    type: 'High' | 'Low' | 'Medium' | 'VeryHigh' | 'VeryLow'
}

export const PriorityTypeOriginal = 'PriorityTypeOriginal';

export function isPriorityTypeOriginal(item: unknown): item is PriorityTypeOriginal {
    return reflection.isInstance(item, PriorityTypeOriginal);
}

export interface QR extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'QR';
    acceptanceCriteria: Array<AcceptanceCriteria>
    description?: string
    expression?: Expression
    isAbstract: boolean
    isConcrete: boolean
    isNegative: boolean
    isPositive: boolean
    isProblem: boolean
    isSolution: boolean
    name: string
    nameAlias?: string
    partOf?: Reference<QR>
    priority?: PriorityType
    stakeholder?: Reference<Stakeholder>
    subType?: QRSubType
    tags: Array<Tag>
    type: QRType
}

export const QR = 'QR';

export function isQR(item: unknown): item is QR {
    return reflection.isInstance(item, QR);
}

export interface QRSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'QRSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const QRSubTypeExtended = 'QRSubTypeExtended';

export function isQRSubTypeExtended(item: unknown): item is QRSubTypeExtended {
    return reflection.isInstance(item, QRSubTypeExtended);
}

export interface QRSubTypeExtendedRef extends AstNode {
    readonly $container: QR;
    readonly $type: 'QRSubTypeExtendedRef';
    type: Reference<QRSubTypeExtended>
}

export const QRSubTypeExtendedRef = 'QRSubTypeExtendedRef';

export function isQRSubTypeExtendedRef(item: unknown): item is QRSubTypeExtendedRef {
    return reflection.isInstance(item, QRSubTypeExtendedRef);
}

export interface QRSubTypeOriginal extends AstNode {
    readonly $container: QR;
    readonly $type: 'QRSubTypeOriginal';
    type: 'Compatibility_CoExistence' | 'Compatibility_Interoperability' | 'Compatibility_Other' | 'Cultural_Currency' | 'Cultural_Language' | 'Cultural_Other' | 'Legal_International' | 'Legal_National' | 'Legal_Other' | 'Maintainability_Analyzability' | 'Maintainability_Modifiability' | 'Maintainability_Modularity' | 'Maintainability_Other' | 'Maintainability_Reusability' | 'Maintainability_Testability' | 'Performance_DiskCapacity' | 'Performance_MemoryCapacity' | 'Performance_NetworkResponseTime' | 'Performance_Other' | 'Performance_SystemResponseTime' | 'Portability_Adaptability' | 'Portability_Installability' | 'Portability_Other' | 'Portability_Replaceability' | 'Privacy_Collection' | 'Privacy_Disclosure' | 'Privacy_Informative' | 'Privacy_Other' | 'Privacy_Retention' | 'Privacy_Usage' | 'Reliability_Availability' | 'Reliability_FaultTolerance' | 'Reliability_Maturity' | 'Reliability_Other' | 'Reliability_Recoverability' | 'Security_Accountability' | 'Security_Authentication' | 'Security_Authorization' | 'Security_Confidentiality' | 'Security_Integrity' | 'Security_NonRepudiation' | 'Security_Other' | 'Security_PhysicalProtection' | 'Security_Recovery' | 'Usability_AappropriatenessRecognizability' | 'Usability_Accessibility' | 'Usability_Learnability' | 'Usability_Operability' | 'Usability_Other' | 'Usability_UserErrorProtection' | 'Usability_UserInterfaceAesthetics'
}

export const QRSubTypeOriginal = 'QRSubTypeOriginal';

export function isQRSubTypeOriginal(item: unknown): item is QRSubTypeOriginal {
    return reflection.isInstance(item, QRSubTypeOriginal);
}

export interface QRTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'QRTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const QRTypeExtended = 'QRTypeExtended';

export function isQRTypeExtended(item: unknown): item is QRTypeExtended {
    return reflection.isInstance(item, QRTypeExtended);
}

export interface QRTypeExtendedRef extends AstNode {
    readonly $container: QR;
    readonly $type: 'QRTypeExtendedRef';
    type: Reference<QRTypeExtended>
}

export const QRTypeExtendedRef = 'QRTypeExtendedRef';

export function isQRTypeExtendedRef(item: unknown): item is QRTypeExtendedRef {
    return reflection.isInstance(item, QRTypeExtendedRef);
}

export interface QRTypeOriginal extends AstNode {
    readonly $container: QR;
    readonly $type: 'QRTypeOriginal';
    type: 'Compatibility' | 'Cultural' | 'Functional' | 'Legal' | 'Maintainability' | 'Other' | 'Performance' | 'Portability' | 'Privacy' | 'Reliability' | 'Security' | 'Usability'
}

export const QRTypeOriginal = 'QRTypeOriginal';

export function isQRTypeOriginal(item: unknown): item is QRTypeOriginal {
    return reflection.isInstance(item, QRTypeOriginal);
}

export interface RefActiveElement extends AstNode {
    readonly $container: ActiveFlow;
    readonly $type: 'RefActiveElement';
    refActiveElement: Array<Reference<ActiveElement>>
}

export const RefActiveElement = 'RefActiveElement';

export function isRefActiveElement(item: unknown): item is RefActiveElement {
    return reflection.isInstance(item, RefActiveElement);
}

export interface RefActor extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'RefActor';
    refs: Array<Reference<Actor>>
}

export const RefActor = 'RefActor';

export function isRefActor(item: unknown): item is RefActor {
    return reflection.isInstance(item, RefActor);
}

export interface RefDataEntity extends AstNode {
    readonly $container: ChildDataEntity | DataEntityCluster;
    readonly $type: 'RefDataEntity';
    refDataEntity: Array<Reference<DataEntity>>
}

export const RefDataEntity = 'RefDataEntity';

export function isRefDataEntity(item: unknown): item is RefDataEntity {
    return reflection.isInstance(item, RefDataEntity);
}

export interface ReferenceElements extends AstNode {
    readonly $container: Theme | View;
    readonly $type: 'ReferenceElements';
    references: Array<Reference<SystemElement>>
}

export const ReferenceElements = 'ReferenceElements';

export function isReferenceElements(item: unknown): item is ReferenceElements {
    return reflection.isInstance(item, ReferenceElements);
}

export interface RefRequirements extends AstNode {
    readonly $container: RiskTreatment | Vulnerability;
    readonly $type: 'RefRequirements';
    refs: Array<Reference<Requirement>>
}

export const RefRequirements = 'RefRequirements';

export function isRefRequirements(item: unknown): item is RefRequirements {
    return reflection.isInstance(item, RefRequirements);
}

export interface RefSystems extends AstNode {
    readonly $type: 'RefSystems';
    refs: Array<Reference<System>>
}

export const RefSystems = 'RefSystems';

export function isRefSystems(item: unknown): item is RefSystems {
    return reflection.isInstance(item, RefSystems);
}

export interface RefTermApplicableTo extends AstNode {
    readonly $container: GlossaryTerm;
    readonly $type: 'RefTermApplicableTo';
    refs: Array<TermApplicableTo>
}

export const RefTermApplicableTo = 'RefTermApplicableTo';

export function isRefTermApplicableTo(item: unknown): item is RefTermApplicableTo {
    return reflection.isInstance(item, RefTermApplicableTo);
}

export interface RefUC extends AstNode {
    readonly $container: UCIncludes;
    readonly $type: 'RefUC';
    refs: Array<Reference<UseCase>>
}

export const RefUC = 'RefUC';

export function isRefUC(item: unknown): item is RefUC {
    return reflection.isInstance(item, RefUC);
}

export interface RefUCAction extends AstNode {
    readonly $container: Transition;
    readonly $type: 'RefUCAction';
    action: ActionType
    useCase: Reference<UseCase>
}

export const RefUCAction = 'RefUCAction';

export function isRefUCAction(item: unknown): item is RefUCAction {
    return reflection.isInstance(item, RefUCAction);
}

export interface RelationTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'RelationTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const RelationTypeExtended = 'RelationTypeExtended';

export function isRelationTypeExtended(item: unknown): item is RelationTypeExtended {
    return reflection.isInstance(item, RelationTypeExtended);
}

export interface RelationTypeExtendedRef extends AstNode {
    readonly $type: 'RelationTypeExtendedRef';
    type: Reference<RelationTypeExtended>
}

export const RelationTypeExtendedRef = 'RelationTypeExtendedRef';

export function isRelationTypeExtendedRef(item: unknown): item is RelationTypeExtendedRef {
    return reflection.isInstance(item, RelationTypeExtendedRef);
}

export interface RelationTypeOriginal extends AstNode {
    readonly $type: 'RelationTypeOriginal';
    type: 'Conflicts' | 'Identical' | 'Obstructs' | 'Other' | 'Relates' | 'Requires' | 'Supports'
}

export const RelationTypeOriginal = 'RelationTypeOriginal';

export function isRelationTypeOriginal(item: unknown): item is RelationTypeOriginal {
    return reflection.isInstance(item, RelationTypeOriginal);
}

export interface RepeatExpression extends AstNode {
    readonly $type: 'RepeatExpression';
    condition: string
}

export const RepeatExpression = 'RepeatExpression';

export function isRepeatExpression(item: unknown): item is RepeatExpression {
    return reflection.isInstance(item, RepeatExpression);
}

export interface RequirementsRelation extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'RequirementsRelation';
    description?: string
    name: string
    nameAlias?: string
    source?: Reference<Requirement>
    tags: Array<Tag>
    target?: Reference<Requirement>
    type: RequirementsRelationType
}

export const RequirementsRelation = 'RequirementsRelation';

export function isRequirementsRelation(item: unknown): item is RequirementsRelation {
    return reflection.isInstance(item, RequirementsRelation);
}

export interface RequirementsRelationTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'RequirementsRelationTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const RequirementsRelationTypeExtended = 'RequirementsRelationTypeExtended';

export function isRequirementsRelationTypeExtended(item: unknown): item is RequirementsRelationTypeExtended {
    return reflection.isInstance(item, RequirementsRelationTypeExtended);
}

export interface RequirementsRelationTypeExtendedRef extends AstNode {
    readonly $container: RequirementsRelation;
    readonly $type: 'RequirementsRelationTypeExtendedRef';
    type: Reference<RequirementsRelationTypeExtended>
}

export const RequirementsRelationTypeExtendedRef = 'RequirementsRelationTypeExtendedRef';

export function isRequirementsRelationTypeExtendedRef(item: unknown): item is RequirementsRelationTypeExtendedRef {
    return reflection.isInstance(item, RequirementsRelationTypeExtendedRef);
}

export interface RequirementsRelationTypeOriginal extends AstNode {
    readonly $container: RequirementsRelation;
    readonly $type: 'RequirementsRelationTypeOriginal';
    type: 'Conflicts' | 'Identical' | 'IsSolution' | 'Obstructs' | 'Other' | 'Relates' | 'Requires' | 'Supports'
}

export const RequirementsRelationTypeOriginal = 'RequirementsRelationTypeOriginal';

export function isRequirementsRelationTypeOriginal(item: unknown): item is RequirementsRelationTypeOriginal {
    return reflection.isInstance(item, RequirementsRelationTypeOriginal);
}

export interface Risk extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Risk';
    acceptanceCriteria: Array<AcceptanceCriteria>
    assessment?: RiskAssessment
    description?: string
    name?: string
    nameAlias?: string
    negativeRequirement?: Reference<Requirement>
    partOf?: Reference<Risk>
    refVulnerabilities: Array<Reference<Vulnerability>>
    status?: RiskStatus
    subType?: RiskSubType
    tags: Array<Tag>
    treatments: Array<RiskTreatment>
    type?: RiskType
}

export const Risk = 'Risk';

export function isRisk(item: unknown): item is Risk {
    return reflection.isInstance(item, Risk);
}

export interface RiskAssessment extends AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskAssessment';
    consequence?: DoubleOrInt
    impact?: DoubleOrInt
    impactLevel?: ImpactLevel
    probability?: DoubleOrInt
}

export const RiskAssessment = 'RiskAssessment';

export function isRiskAssessment(item: unknown): item is RiskAssessment {
    return reflection.isInstance(item, RiskAssessment);
}

export interface RiskStatus extends AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskStatus';
    type: 'Assessed' | 'Closed' | 'Identified' | 'NotOccurred' | 'OnProcess' | 'Planned' | 'Rejected'
}

export const RiskStatus = 'RiskStatus';

export function isRiskStatus(item: unknown): item is RiskStatus {
    return reflection.isInstance(item, RiskStatus);
}

export interface RiskSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'RiskSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const RiskSubTypeExtended = 'RiskSubTypeExtended';

export function isRiskSubTypeExtended(item: unknown): item is RiskSubTypeExtended {
    return reflection.isInstance(item, RiskSubTypeExtended);
}

export interface RiskSubTypeExtendedRef extends AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskSubTypeExtendedRef';
    type: Reference<RiskSubTypeExtended>
}

export const RiskSubTypeExtendedRef = 'RiskSubTypeExtendedRef';

export function isRiskSubTypeExtendedRef(item: unknown): item is RiskSubTypeExtendedRef {
    return reflection.isInstance(item, RiskSubTypeExtendedRef);
}

export interface RiskSubTypeOriginal extends AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskSubTypeOriginal';
    type: 'Business_Compliance' | 'Business_Financial' | 'Business_Operational' | 'Business_Strategic' | 'IT_DenialOfService' | 'IT_ElevationOfPrivilege' | 'IT_InformationDisclosure' | 'IT_Repudiation' | 'IT_Spoofing' | 'IT_Tampering' | 'Other' | 'Project_Budget' | 'Project_Quality' | 'Project_Resource' | 'Project_Schedule' | 'Project_Scope'
}

export const RiskSubTypeOriginal = 'RiskSubTypeOriginal';

export function isRiskSubTypeOriginal(item: unknown): item is RiskSubTypeOriginal {
    return reflection.isInstance(item, RiskSubTypeOriginal);
}

export interface RiskTreatment extends AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskTreatment';
    description?: string
    name?: string
    nameAlias?: string
    owner?: Reference<Stakeholder>
    solution?: RefRequirements
    type?: RiskTreatmentType
}

export const RiskTreatment = 'RiskTreatment';

export function isRiskTreatment(item: unknown): item is RiskTreatment {
    return reflection.isInstance(item, RiskTreatment);
}

export interface RiskTreatmentTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'RiskTreatmentTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const RiskTreatmentTypeExtended = 'RiskTreatmentTypeExtended';

export function isRiskTreatmentTypeExtended(item: unknown): item is RiskTreatmentTypeExtended {
    return reflection.isInstance(item, RiskTreatmentTypeExtended);
}

export interface RiskTreatmentTypeExtendedRef extends AstNode {
    readonly $container: RiskTreatment;
    readonly $type: 'RiskTreatmentTypeExtendedRef';
    type: Reference<RiskTreatmentTypeExtended>
}

export const RiskTreatmentTypeExtendedRef = 'RiskTreatmentTypeExtendedRef';

export function isRiskTreatmentTypeExtendedRef(item: unknown): item is RiskTreatmentTypeExtendedRef {
    return reflection.isInstance(item, RiskTreatmentTypeExtendedRef);
}

export interface RiskTreatmentTypeOriginal extends AstNode {
    readonly $container: RiskTreatment;
    readonly $type: 'RiskTreatmentTypeOriginal';
    type: 'Accept' | 'Avoid' | 'Mitigate' | 'Transfer'
}

export const RiskTreatmentTypeOriginal = 'RiskTreatmentTypeOriginal';

export function isRiskTreatmentTypeOriginal(item: unknown): item is RiskTreatmentTypeOriginal {
    return reflection.isInstance(item, RiskTreatmentTypeOriginal);
}

export interface RiskTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'RiskTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const RiskTypeExtended = 'RiskTypeExtended';

export function isRiskTypeExtended(item: unknown): item is RiskTypeExtended {
    return reflection.isInstance(item, RiskTypeExtended);
}

export interface RiskTypeExtendedRef extends AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskTypeExtendedRef';
    type: Reference<RiskTypeExtended>
}

export const RiskTypeExtendedRef = 'RiskTypeExtendedRef';

export function isRiskTypeExtendedRef(item: unknown): item is RiskTypeExtendedRef {
    return reflection.isInstance(item, RiskTypeExtendedRef);
}

export interface RiskTypeOriginal extends AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskTypeOriginal';
    type: 'Business' | 'IT' | 'Other' | 'Project'
}

export const RiskTypeOriginal = 'RiskTypeOriginal';

export function isRiskTypeOriginal(item: unknown): item is RiskTypeOriginal {
    return reflection.isInstance(item, RiskTypeOriginal);
}

export interface Scenario extends AstNode {
    readonly $container: Step;
    readonly $type: 'Scenario';
    description?: string
    name: string
    nameAlias: string
    repeat?: string
    steps: Array<Step>
    type: ScenarioType
}

export const Scenario = 'Scenario';

export function isScenario(item: unknown): item is Scenario {
    return reflection.isInstance(item, Scenario);
}

export interface ScenarioTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'ScenarioTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const ScenarioTypeExtended = 'ScenarioTypeExtended';

export function isScenarioTypeExtended(item: unknown): item is ScenarioTypeExtended {
    return reflection.isInstance(item, ScenarioTypeExtended);
}

export interface ScenarioTypeExtendedRef extends AstNode {
    readonly $container: Scenario;
    readonly $type: 'ScenarioTypeExtendedRef';
    type: Reference<ScenarioTypeExtended>
}

export const ScenarioTypeExtendedRef = 'ScenarioTypeExtendedRef';

export function isScenarioTypeExtendedRef(item: unknown): item is ScenarioTypeExtendedRef {
    return reflection.isInstance(item, ScenarioTypeExtendedRef);
}

export interface ScenarioTypeOriginal extends AstNode {
    readonly $container: Scenario;
    readonly $type: 'ScenarioTypeOriginal';
    type: 'Alternative' | 'Exception' | 'Nested'
}

export const ScenarioTypeOriginal = 'ScenarioTypeOriginal';

export function isScenarioTypeOriginal(item: unknown): item is ScenarioTypeOriginal {
    return reflection.isInstance(item, ScenarioTypeOriginal);
}

export interface SimpleTestStep extends AstNode {
    readonly $type: 'SimpleTestStep';
    actor?: Reference<Actor>
    description?: string
    nameAlias: string
    next?: Reference<TestStep>
    postcondition?: string
    precondition?: string
}

export const SimpleTestStep = 'SimpleTestStep';

export function isSimpleTestStep(item: unknown): item is SimpleTestStep {
    return reflection.isInstance(item, SimpleTestStep);
}

export interface Stakeholder extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Stakeholder';
    description?: string
    name: string
    nameAlias?: string
    partOf?: Reference<Stakeholder>
    subType?: StakeholderSubType
    super?: Reference<Stakeholder>
    tags: Array<Tag>
    type: StakeholderType
}

export const Stakeholder = 'Stakeholder';

export function isStakeholder(item: unknown): item is Stakeholder {
    return reflection.isInstance(item, Stakeholder);
}

export interface StakeholderSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StakeholderSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const StakeholderSubTypeExtended = 'StakeholderSubTypeExtended';

export function isStakeholderSubTypeExtended(item: unknown): item is StakeholderSubTypeExtended {
    return reflection.isInstance(item, StakeholderSubTypeExtended);
}

export interface StakeholderSubTypeExtendedRef extends AstNode {
    readonly $container: Stakeholder;
    readonly $type: 'StakeholderSubTypeExtendedRef';
    type: Reference<StakeholderSubTypeExtended>
}

export const StakeholderSubTypeExtendedRef = 'StakeholderSubTypeExtendedRef';

export function isStakeholderSubTypeExtendedRef(item: unknown): item is StakeholderSubTypeExtendedRef {
    return reflection.isInstance(item, StakeholderSubTypeExtendedRef);
}

export interface StakeholderSubTypeOriginal extends AstNode {
    readonly $container: Stakeholder;
    readonly $type: 'StakeholderSubTypeOriginal';
    type: 'Organization_Customer' | 'Organization_Government' | 'Organization_Owner' | 'Organization_Partner' | 'Organization_RegulatorAgent' | 'Organization_Sponsor' | 'OrganizationalUnit_IT' | 'OrganizationalUnit_Operations' | 'OrganizationalUnit_Other' | 'OrganizationalUnit_Support' | 'Other' | 'Person_Manager' | 'Person_Manager_FunctionalManager' | 'Person_Manager_ProjectManager' | 'Person_Manager_TeamManager' | 'Person_Technical' | 'Person_Technical_BusinessAnalyst' | 'Person_Technical_RequirementsEngineer' | 'Person_Technical_SoftwareArchitect' | 'Person_Technical_SoftwareDesigner' | 'Person_Technical_SoftwareDeveloper' | 'Person_Technical_SoftwareTester' | 'Person_Technical_Trainee' | 'Person_Technical_Trainer' | 'Person_User' | 'System_External' | 'System_Internal' | 'System_Other'
}

export const StakeholderSubTypeOriginal = 'StakeholderSubTypeOriginal';

export function isStakeholderSubTypeOriginal(item: unknown): item is StakeholderSubTypeOriginal {
    return reflection.isInstance(item, StakeholderSubTypeOriginal);
}

export interface StakeholderTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StakeholderTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const StakeholderTypeExtended = 'StakeholderTypeExtended';

export function isStakeholderTypeExtended(item: unknown): item is StakeholderTypeExtended {
    return reflection.isInstance(item, StakeholderTypeExtended);
}

export interface StakeholderTypeExtendedRef extends AstNode {
    readonly $container: Stakeholder;
    readonly $type: 'StakeholderTypeExtendedRef';
    type: Reference<StakeholderTypeExtended>
}

export const StakeholderTypeExtendedRef = 'StakeholderTypeExtendedRef';

export function isStakeholderTypeExtendedRef(item: unknown): item is StakeholderTypeExtendedRef {
    return reflection.isInstance(item, StakeholderTypeExtendedRef);
}

export interface StakeholderTypeOriginal extends AstNode {
    readonly $container: Stakeholder;
    readonly $type: 'StakeholderTypeOriginal';
    type: 'Organization' | 'OrganizationalUnit' | 'Other' | 'Person' | 'System'
}

export const StakeholderTypeOriginal = 'StakeholderTypeOriginal';

export function isStakeholderTypeOriginal(item: unknown): item is StakeholderTypeOriginal {
    return reflection.isInstance(item, StakeholderTypeOriginal);
}

export interface State extends AstNode {
    readonly $container: State | StateMachine;
    readonly $type: 'State';
    isFinal: boolean
    isInitial: boolean
    name?: string
    nameAlias?: string
    onEntry?: string
    onExit?: string
    states: Array<State>
    transitions: Array<Transition>
}

export const State = 'State';

export function isState(item: unknown): item is State {
    return reflection.isInstance(item, State);
}

export interface StateMachine extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StateMachine';
    description?: string
    entity?: Reference<DataEntityGeneric>
    name: string
    nameAlias?: string
    states?: States
    tags: Array<Tag>
    type: StateMachineType
}

export const StateMachine = 'StateMachine';

export function isStateMachine(item: unknown): item is StateMachine {
    return reflection.isInstance(item, StateMachine);
}

export interface StateMachineTest extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StateMachineTest';
    description?: string
    message?: string
    name: string
    nameAlias?: string
    stateMachine?: Reference<StateMachine>
    stateSequence?: StateSequence
    tags: Array<Tag>
    type: TestType
}

export const StateMachineTest = 'StateMachineTest';

export function isStateMachineTest(item: unknown): item is StateMachineTest {
    return reflection.isInstance(item, StateMachineTest);
}

export interface StateMachineTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StateMachineTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const StateMachineTypeExtended = 'StateMachineTypeExtended';

export function isStateMachineTypeExtended(item: unknown): item is StateMachineTypeExtended {
    return reflection.isInstance(item, StateMachineTypeExtended);
}

export interface StateMachineTypeExtendedRef extends AstNode {
    readonly $container: StateMachine;
    readonly $type: 'StateMachineTypeExtendedRef';
    type: Reference<StateMachineTypeExtended>
}

export const StateMachineTypeExtendedRef = 'StateMachineTypeExtendedRef';

export function isStateMachineTypeExtendedRef(item: unknown): item is StateMachineTypeExtendedRef {
    return reflection.isInstance(item, StateMachineTypeExtendedRef);
}

export interface StateMachineTypeOriginal extends AstNode {
    readonly $container: StateMachine;
    readonly $type: 'StateMachineTypeOriginal';
    type: 'Complex' | 'Simple'
}

export const StateMachineTypeOriginal = 'StateMachineTypeOriginal';

export function isStateMachineTypeOriginal(item: unknown): item is StateMachineTypeOriginal {
    return reflection.isInstance(item, StateMachineTypeOriginal);
}

export interface StateSequence extends AstNode {
    readonly $container: StateMachineTest;
    readonly $type: 'StateSequence';
    refState: Array<Reference<State>>
}

export const StateSequence = 'StateSequence';

export function isStateSequence(item: unknown): item is StateSequence {
    return reflection.isInstance(item, StateSequence);
}

export interface Step extends AstNode {
    readonly $container: MainScenario | Scenario;
    readonly $type: 'Step';
    actor?: Reference<Actor>
    description?: string
    name: string
    nameAlias: string
    next?: Reference<Step>
    repeat?: string
    scenarios: Array<Scenario>
    subSubType?: StepSubSubType
    subType?: StepSubType
    type?: StepType
    typeUC?: StepOperationUCType
    usecase?: Reference<UseCase>
}

export const Step = 'Step';

export function isStep(item: unknown): item is Step {
    return reflection.isInstance(item, Step);
}

export interface StepOperationUCType extends AstNode {
    readonly $container: Step;
    readonly $type: 'StepOperationUCType';
    type: 'extendedBy' | 'include'
}

export const StepOperationUCType = 'StepOperationUCType';

export function isStepOperationUCType(item: unknown): item is StepOperationUCType {
    return reflection.isInstance(item, StepOperationUCType);
}

export interface StepSubSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StepSubSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const StepSubSubTypeExtended = 'StepSubSubTypeExtended';

export function isStepSubSubTypeExtended(item: unknown): item is StepSubSubTypeExtended {
    return reflection.isInstance(item, StepSubSubTypeExtended);
}

export interface StepSubSubTypeExtendedRef extends AstNode {
    readonly $container: OperationExtension | Step;
    readonly $type: 'StepSubSubTypeExtendedRef';
    type: Reference<StepSubSubTypeExtended>
}

export const StepSubSubTypeExtendedRef = 'StepSubSubTypeExtendedRef';

export function isStepSubSubTypeExtendedRef(item: unknown): item is StepSubSubTypeExtendedRef {
    return reflection.isInstance(item, StepSubSubTypeExtendedRef);
}

export interface StepSubSubTypeOriginal extends AstNode {
    readonly $container: OperationExtension | Step;
    readonly $type: 'StepSubSubTypeOriginal';
    type: 'CancelAction' | 'Check' | 'Click' | 'CloseBrowser' | 'Fill' | 'GetData' | 'OpenBrowser' | 'Other' | 'Over' | 'PostData' | 'Reload' | 'Select' | 'ShowData' | 'Submit' | 'SubmitAction' | 'TerminateAction'
}

export const StepSubSubTypeOriginal = 'StepSubSubTypeOriginal';

export function isStepSubSubTypeOriginal(item: unknown): item is StepSubSubTypeOriginal {
    return reflection.isInstance(item, StepSubSubTypeOriginal);
}

export interface StepSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StepSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const StepSubTypeExtended = 'StepSubTypeExtended';

export function isStepSubTypeExtended(item: unknown): item is StepSubTypeExtended {
    return reflection.isInstance(item, StepSubTypeExtended);
}

export interface StepSubTypeExtendedRef extends AstNode {
    readonly $container: Step;
    readonly $type: 'StepSubTypeExtendedRef';
    type: Reference<StepSubTypeExtended>
}

export const StepSubTypeExtendedRef = 'StepSubTypeExtendedRef';

export function isStepSubTypeExtendedRef(item: unknown): item is StepSubTypeExtendedRef {
    return reflection.isInstance(item, StepSubTypeExtendedRef);
}

export interface StepSubTypeOriginal extends AstNode {
    readonly $container: Step;
    readonly $type: 'StepSubTypeOriginal';
    type: 'CallSystem' | 'Execute' | 'Other' | 'PrepareData' | 'ReturnResult'
}

export const StepSubTypeOriginal = 'StepSubTypeOriginal';

export function isStepSubTypeOriginal(item: unknown): item is StepSubTypeOriginal {
    return reflection.isInstance(item, StepSubTypeOriginal);
}

export interface StepTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StepTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const StepTypeExtended = 'StepTypeExtended';

export function isStepTypeExtended(item: unknown): item is StepTypeExtended {
    return reflection.isInstance(item, StepTypeExtended);
}

export interface StepTypeExtendedRef extends AstNode {
    readonly $container: Step | TestStep;
    readonly $type: 'StepTypeExtendedRef';
    type: Reference<StepTypeExtended>
}

export const StepTypeExtendedRef = 'StepTypeExtendedRef';

export function isStepTypeExtendedRef(item: unknown): item is StepTypeExtendedRef {
    return reflection.isInstance(item, StepTypeExtendedRef);
}

export interface StepTypeOriginal extends AstNode {
    readonly $container: Step | TestStep;
    readonly $type: 'StepTypeOriginal';
    type: 'Actor' | 'Other' | 'System'
}

export const StepTypeOriginal = 'StepTypeOriginal';

export function isStepTypeOriginal(item: unknown): item is StepTypeOriginal {
    return reflection.isInstance(item, StepTypeOriginal);
}

export interface Stereotype extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Stereotype';
    description?: string
    name: string
    nameAlias?: string
    tags: Array<Tag>
    type: StereotypeType
}

export const Stereotype = 'Stereotype';

export function isStereotype(item: unknown): item is Stereotype {
    return reflection.isInstance(item, Stereotype);
}

export interface StereotypeTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'StereotypeTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const StereotypeTypeExtended = 'StereotypeTypeExtended';

export function isStereotypeTypeExtended(item: unknown): item is StereotypeTypeExtended {
    return reflection.isInstance(item, StereotypeTypeExtended);
}

export interface StereotypeTypeExtendedRef extends AstNode {
    readonly $container: Stereotype;
    readonly $type: 'StereotypeTypeExtendedRef';
    type: Reference<StereotypeTypeExtended>
}

export const StereotypeTypeExtendedRef = 'StereotypeTypeExtendedRef';

export function isStereotypeTypeExtendedRef(item: unknown): item is StereotypeTypeExtendedRef {
    return reflection.isInstance(item, StereotypeTypeExtendedRef);
}

export interface StereotypeTypeOriginal extends AstNode {
    readonly $container: Stereotype;
    readonly $type: 'StereotypeTypeOriginal';
    type: 'AcceptanceCriteriaTestView' | 'ActiveEvent' | 'ActiveTask' | 'Actor' | 'Constraint' | 'DataEntity' | 'DataEntityCluster' | 'DataEntityTestView' | 'FR' | 'GlossaryTerm' | 'Goal' | 'Other' | 'QR' | 'Risk' | 'Stakeholder' | 'StateMachine' | 'StatemachineTestView' | 'System' | 'UseCase' | 'UseCaseTestView' | 'UserStory' | 'Vulnerability'
}

export const StereotypeTypeOriginal = 'StereotypeTypeOriginal';

export function isStereotypeTypeOriginal(item: unknown): item is StereotypeTypeOriginal {
    return reflection.isInstance(item, StereotypeTypeOriginal);
}

export interface System extends AstNode {
    readonly $container: PackageSystem;
    readonly $type: 'System';
    description?: string
    isFinal: boolean
    isReusable: boolean
    isTestSuite: boolean
    name: string
    nameAlias?: string
    partOf?: Reference<System>
    subType?: SystemSubType
    sut?: Reference<System>
    systemConcepts: Array<SystemConcept>
    tags: Array<Tag>
    type: SystemType
    vendor?: string
    version?: string
}

export const System = 'System';

export function isSystem(item: unknown): item is System {
    return reflection.isInstance(item, System);
}

export interface SystemsRelation extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'SystemsRelation';
    category?: SystemsRelationCategory
    description?: string
    name: string
    nameAlias?: string
    source?: Reference<System>
    tags: Array<Tag>
    target?: Reference<System>
    type: SystemsRelationType
}

export const SystemsRelation = 'SystemsRelation';

export function isSystemsRelation(item: unknown): item is SystemsRelation {
    return reflection.isInstance(item, SystemsRelation);
}

export interface SystemsRelationCategoryExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'SystemsRelationCategoryExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const SystemsRelationCategoryExtended = 'SystemsRelationCategoryExtended';

export function isSystemsRelationCategoryExtended(item: unknown): item is SystemsRelationCategoryExtended {
    return reflection.isInstance(item, SystemsRelationCategoryExtended);
}

export interface SystemsRelationCategoryExtendedRef extends AstNode {
    readonly $container: SystemsRelation;
    readonly $type: 'SystemsRelationCategoryExtendedRef';
    type: Reference<SystemsRelationCategoryExtended>
}

export const SystemsRelationCategoryExtendedRef = 'SystemsRelationCategoryExtendedRef';

export function isSystemsRelationCategoryExtendedRef(item: unknown): item is SystemsRelationCategoryExtendedRef {
    return reflection.isInstance(item, SystemsRelationCategoryExtendedRef);
}

export interface SystemsRelationCategoryOriginal extends AstNode {
    readonly $container: SystemsRelation;
    readonly $type: 'SystemsRelationCategoryOriginal';
    type: 'Export' | 'Import' | 'ImportExport' | 'Interact' | 'Other' | 'Sync'
}

export const SystemsRelationCategoryOriginal = 'SystemsRelationCategoryOriginal';

export function isSystemsRelationCategoryOriginal(item: unknown): item is SystemsRelationCategoryOriginal {
    return reflection.isInstance(item, SystemsRelationCategoryOriginal);
}

export interface SystemsRelationTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'SystemsRelationTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const SystemsRelationTypeExtended = 'SystemsRelationTypeExtended';

export function isSystemsRelationTypeExtended(item: unknown): item is SystemsRelationTypeExtended {
    return reflection.isInstance(item, SystemsRelationTypeExtended);
}

export interface SystemsRelationTypeExtendedRef extends AstNode {
    readonly $container: SystemsRelation;
    readonly $type: 'SystemsRelationTypeExtendedRef';
    type: Reference<SystemsRelationTypeExtended>
}

export const SystemsRelationTypeExtendedRef = 'SystemsRelationTypeExtendedRef';

export function isSystemsRelationTypeExtendedRef(item: unknown): item is SystemsRelationTypeExtendedRef {
    return reflection.isInstance(item, SystemsRelationTypeExtendedRef);
}

export interface SystemsRelationTypeOriginal extends AstNode {
    readonly $container: SystemsRelation;
    readonly $type: 'SystemsRelationTypeOriginal';
    type: 'Conflicts' | 'Identical' | 'Obstructs' | 'Other' | 'Relates' | 'Requires' | 'Supports'
}

export const SystemsRelationTypeOriginal = 'SystemsRelationTypeOriginal';

export function isSystemsRelationTypeOriginal(item: unknown): item is SystemsRelationTypeOriginal {
    return reflection.isInstance(item, SystemsRelationTypeOriginal);
}

export interface SystemSubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'SystemSubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const SystemSubTypeExtended = 'SystemSubTypeExtended';

export function isSystemSubTypeExtended(item: unknown): item is SystemSubTypeExtended {
    return reflection.isInstance(item, SystemSubTypeExtended);
}

export interface SystemSubTypeExtendedRef extends AstNode {
    readonly $container: System;
    readonly $type: 'SystemSubTypeExtendedRef';
    type: Reference<SystemSubTypeExtended>
}

export const SystemSubTypeExtendedRef = 'SystemSubTypeExtendedRef';

export function isSystemSubTypeExtendedRef(item: unknown): item is SystemSubTypeExtendedRef {
    return reflection.isInstance(item, SystemSubTypeExtendedRef);
}

export interface SystemSubTypeOriginal extends AstNode {
    readonly $container: System;
    readonly $type: 'SystemSubTypeOriginal';
    type: 'Application_Actuator' | 'Application_Desktop' | 'Application_Mobile' | 'Application_Other' | 'Application_Sensor' | 'Application_Web' | 'Business_IT' | 'Business_Other' | 'Business_PublicSector' | 'HardwareSystem_Actuator' | 'HardwareSystem_Desktop' | 'HardwareSystem_Laptop' | 'HardwareSystem_Network' | 'HardwareSystem_Other' | 'HardwareSystem_Printer' | 'HardwareSystem_Sensor' | 'HardwareSystem_Server' | 'HardwareSystem_Smartphone' | 'HardwareSystem_Smartwatch' | 'HardwareSystem_Storage' | 'SoftwareSystem_DBMS' | 'SoftwareSystem_EmailClient' | 'SoftwareSystem_EmailServer' | 'SoftwareSystem_OS' | 'SoftwareSystem_OfficeTool' | 'SoftwareSystem_Other' | 'SoftwareSystem_OtherClient' | 'SoftwareSystem_OtherServer' | 'SoftwareSystem_VM' | 'SoftwareSystem_WebClient' | 'SoftwareSystem_WebServer'
}

export const SystemSubTypeOriginal = 'SystemSubTypeOriginal';

export function isSystemSubTypeOriginal(item: unknown): item is SystemSubTypeOriginal {
    return reflection.isInstance(item, SystemSubTypeOriginal);
}

export interface SystemTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'SystemTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const SystemTypeExtended = 'SystemTypeExtended';

export function isSystemTypeExtended(item: unknown): item is SystemTypeExtended {
    return reflection.isInstance(item, SystemTypeExtended);
}

export interface SystemTypeExtendedRef extends AstNode {
    readonly $container: System;
    readonly $type: 'SystemTypeExtendedRef';
    type: Reference<SystemTypeExtended>
}

export const SystemTypeExtendedRef = 'SystemTypeExtendedRef';

export function isSystemTypeExtendedRef(item: unknown): item is SystemTypeExtendedRef {
    return reflection.isInstance(item, SystemTypeExtendedRef);
}

export interface SystemTypeOriginal extends AstNode {
    readonly $container: System;
    readonly $type: 'SystemTypeOriginal';
    type: 'Application' | 'Business' | 'HardwareSystem' | 'Other' | 'SoftwareSystem'
}

export const SystemTypeOriginal = 'SystemTypeOriginal';

export function isSystemTypeOriginal(item: unknown): item is SystemTypeOriginal {
    return reflection.isInstance(item, SystemTypeOriginal);
}

export interface Tag extends AstNode {
    readonly $container: AcceptanceCriteria | AcceptanceCriteriaTest | ActiveEvent | ActiveFlow | ActiveTask | Actor | Constraint | Data | DataAttribute | DataEntity | DataEntityCluster | DataEntityTest | DataEnumeration | ElementsRelation | FR | GlossaryTerm | Goal | IncludeAll | IncludeElement | QR | RequirementsRelation | Risk | Stakeholder | StateMachine | StateMachineTest | Stereotype | System | SystemsRelation | TestsRelation | Theme | UseCase | UseCaseTest | UserStory | View | Vulnerability;
    readonly $type: 'Tag';
    nameAlias: string
    value?: string
}

export const Tag = 'Tag';

export function isTag(item: unknown): item is Tag {
    return reflection.isInstance(item, Tag);
}

export interface TermApplicableTo extends AstNode {
    readonly $container: RefTermApplicableTo;
    readonly $type: 'TermApplicableTo';
    type: 'Actor' | 'DataEntity' | 'Other' | 'Stakeholder' | 'System'
}

export const TermApplicableTo = 'TermApplicableTo';

export function isTermApplicableTo(item: unknown): item is TermApplicableTo {
    return reflection.isInstance(item, TermApplicableTo);
}

export interface TestCheck extends AstNode {
    readonly $container: OperationExtension;
    readonly $type: 'TestCheck';
    codeString?: string
    codeVariable?: Reference<DataAttribute>
    expected?: Reference<DataAttribute>
    limitINT?: number
    limitVariable?: Reference<DataAttribute>
    metric?: MetricType
    textString?: string
    textVariable?: Reference<DataAttribute>
    timeoutINT?: DoubleOrInt
    timeoutVariable?: Reference<DataAttribute>
    type: CheckType
    urlString?: string
    urlVariable?: Reference<DataAttribute>
    variable?: Reference<DataAttribute>
}

export const TestCheck = 'TestCheck';

export function isTestCheck(item: unknown): item is TestCheck {
    return reflection.isInstance(item, TestCheck);
}

export interface TestDataAttribute extends AstNode {
    readonly $container: DataEntityTest;
    readonly $type: 'TestDataAttribute';
    attribute: Reference<DataAttribute>
    message?: string
    type?: DataAttributeType
    values?: string
}

export const TestDataAttribute = 'TestDataAttribute';

export function isTestDataAttribute(item: unknown): item is TestDataAttribute {
    return reflection.isInstance(item, TestDataAttribute);
}

export interface TestOperationTarget extends AstNode {
    readonly $container: OperationExtension;
    readonly $type: 'TestOperationTarget';
    content: Array<string>
    type: OperationTargetType
    variable: Array<Reference<DataAttribute>>
}

export const TestOperationTarget = 'TestOperationTarget';

export function isTestOperationTarget(item: unknown): item is TestOperationTarget {
    return reflection.isInstance(item, TestOperationTarget);
}

export interface TestScenario extends AstNode {
    readonly $container: UseCaseTest;
    readonly $type: 'TestScenario';
    description?: string
    entity?: Reference<DataEntity>
    entityTable?: DataAttributeValues
    isAbstract: boolean
    isConcrete: boolean
    name: string
    nameAlias?: string
    testSteps: Array<TestStep>
    type: TestScenarioType
    variable?: Reference<TestVariable>
    variableTable?: DataVariableValues
}

export const TestScenario = 'TestScenario';

export function isTestScenario(item: unknown): item is TestScenario {
    return reflection.isInstance(item, TestScenario);
}

export interface TestScenarioTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'TestScenarioTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const TestScenarioTypeExtended = 'TestScenarioTypeExtended';

export function isTestScenarioTypeExtended(item: unknown): item is TestScenarioTypeExtended {
    return reflection.isInstance(item, TestScenarioTypeExtended);
}

export interface TestScenarioTypeExtendedRef extends AstNode {
    readonly $container: TestScenario;
    readonly $type: 'TestScenarioTypeExtendedRef';
    type: Reference<TestScenarioTypeExtended>
}

export const TestScenarioTypeExtendedRef = 'TestScenarioTypeExtendedRef';

export function isTestScenarioTypeExtendedRef(item: unknown): item is TestScenarioTypeExtendedRef {
    return reflection.isInstance(item, TestScenarioTypeExtendedRef);
}

export interface TestScenarioTypeOriginal extends AstNode {
    readonly $container: TestScenario;
    readonly $type: 'TestScenarioTypeOriginal';
    type: 'Alternative' | 'Exception' | 'Main'
}

export const TestScenarioTypeOriginal = 'TestScenarioTypeOriginal';

export function isTestScenarioTypeOriginal(item: unknown): item is TestScenarioTypeOriginal {
    return reflection.isInstance(item, TestScenarioTypeOriginal);
}

export interface TestsRelation extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'TestsRelation';
    description?: string
    name: string
    nameAlias?: string
    source?: Reference<Test>
    tags: Array<Tag>
    target?: Reference<Test>
    type: TestsRelationType
}

export const TestsRelation = 'TestsRelation';

export function isTestsRelation(item: unknown): item is TestsRelation {
    return reflection.isInstance(item, TestsRelation);
}

export interface TestsRelationTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'TestsRelationTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const TestsRelationTypeExtended = 'TestsRelationTypeExtended';

export function isTestsRelationTypeExtended(item: unknown): item is TestsRelationTypeExtended {
    return reflection.isInstance(item, TestsRelationTypeExtended);
}

export interface TestsRelationTypeExtendedRef extends AstNode {
    readonly $container: TestsRelation;
    readonly $type: 'TestsRelationTypeExtendedRef';
    type: Reference<TestsRelationTypeExtended>
}

export const TestsRelationTypeExtendedRef = 'TestsRelationTypeExtendedRef';

export function isTestsRelationTypeExtendedRef(item: unknown): item is TestsRelationTypeExtendedRef {
    return reflection.isInstance(item, TestsRelationTypeExtendedRef);
}

export interface TestsRelationTypeOriginal extends AstNode {
    readonly $container: TestsRelation;
    readonly $type: 'TestsRelationTypeOriginal';
    type: 'Conflicts' | 'Identical' | 'Obstructs' | 'Other' | 'Relates' | 'Requires' | 'Supports'
}

export const TestsRelationTypeOriginal = 'TestsRelationTypeOriginal';

export function isTestsRelationTypeOriginal(item: unknown): item is TestsRelationTypeOriginal {
    return reflection.isInstance(item, TestsRelationTypeOriginal);
}

export interface TestStep extends AstNode {
    readonly $container: TestScenario;
    readonly $type: 'TestStep';
    actor?: Reference<Actor>
    description?: string
    extension?: OperationExtension
    name: string
    nameAlias: string
    next?: Reference<Step>
    repeat?: string
    type: StepType
}

export const TestStep = 'TestStep';

export function isTestStep(item: unknown): item is TestStep {
    return reflection.isInstance(item, TestStep);
}

export interface TestTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'TestTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const TestTypeExtended = 'TestTypeExtended';

export function isTestTypeExtended(item: unknown): item is TestTypeExtended {
    return reflection.isInstance(item, TestTypeExtended);
}

export interface TestTypeExtendedRef extends AstNode {
    readonly $container: AcceptanceCriteria | AcceptanceCriteriaTest | DataEntityTest | StateMachineTest | UseCaseTest;
    readonly $type: 'TestTypeExtendedRef';
    type: Reference<TestTypeExtended>
}

export const TestTypeExtendedRef = 'TestTypeExtendedRef';

export function isTestTypeExtendedRef(item: unknown): item is TestTypeExtendedRef {
    return reflection.isInstance(item, TestTypeExtendedRef);
}

export interface TestTypeOriginal extends AstNode {
    readonly $container: AcceptanceCriteria | AcceptanceCriteriaTest | DataEntityTest | StateMachineTest | UseCaseTest;
    readonly $type: 'TestTypeOriginal';
    type: 'Invalid' | 'Valid'
}

export const TestTypeOriginal = 'TestTypeOriginal';

export function isTestTypeOriginal(item: unknown): item is TestTypeOriginal {
    return reflection.isInstance(item, TestTypeOriginal);
}

export interface TestVariable extends AstNode {
    readonly $container: UseCaseTest;
    readonly $type: 'TestVariable';
    attributes: Array<DataAttribute>
    description?: string
    name: string
    nameAlias?: string
}

export const TestVariable = 'TestVariable';

export function isTestVariable(item: unknown): item is TestVariable {
    return reflection.isInstance(item, TestVariable);
}

export interface Theme extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Theme';
    description?: string
    elements: ReferenceElements
    name: string
    nameAlias?: string
    tags: Array<Tag>
    type: ThemeType
}

export const Theme = 'Theme';

export function isTheme(item: unknown): item is Theme {
    return reflection.isInstance(item, Theme);
}

export interface ThemeType extends AstNode {
    readonly $container: Theme;
    readonly $type: 'ThemeType';
    type: 'BehaviorElementTheme' | 'OtherTheme' | 'RequirementTheme' | 'StructureElementTheme' | 'SystemElementTheme' | 'TestTheme'
}

export const ThemeType = 'ThemeType';

export function isThemeType(item: unknown): item is ThemeType {
    return reflection.isInstance(item, ThemeType);
}

export interface Threat extends AstNode {
    readonly $type: 'Threat';
    value: Risk
}

export const Threat = 'Threat';

export function isThreat(item: unknown): item is Threat {
    return reflection.isInstance(item, Threat);
}

export interface Transition extends AstNode {
    readonly $container: State;
    readonly $type: 'Transition';
    nextstate?: Reference<State>
    ucAction: RefUCAction
}

export const Transition = 'Transition';

export function isTransition(item: unknown): item is Transition {
    return reflection.isInstance(item, Transition);
}

export interface UCActions extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'UCActions';
    actions: Array<ActionType>
}

export const UCActions = 'UCActions';

export function isUCActions(item: unknown): item is UCActions {
    return reflection.isInstance(item, UCActions);
}

export interface UCExtends extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'UCExtends';
    extensionPoint: Reference<UCExtensionPoint>
    usecase: Reference<UseCase>
}

export const UCExtends = 'UCExtends';

export function isUCExtends(item: unknown): item is UCExtends {
    return reflection.isInstance(item, UCExtends);
}

export interface UCExtensionPoint extends AstNode {
    readonly $container: UCExtensionPoints;
    readonly $type: 'UCExtensionPoint';
    description?: string
    name: string
}

export const UCExtensionPoint = 'UCExtensionPoint';

export function isUCExtensionPoint(item: unknown): item is UCExtensionPoint {
    return reflection.isInstance(item, UCExtensionPoint);
}

export interface UCExtensionPoints extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'UCExtensionPoints';
    extensionPoints: Array<UCExtensionPoint>
}

export const UCExtensionPoints = 'UCExtensionPoints';

export function isUCExtensionPoints(item: unknown): item is UCExtensionPoints {
    return reflection.isInstance(item, UCExtensionPoints);
}

export interface UCIncludes extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'UCIncludes';
    includes: Array<RefUC>
}

export const UCIncludes = 'UCIncludes';

export function isUCIncludes(item: unknown): item is UCIncludes {
    return reflection.isInstance(item, UCIncludes);
}

export interface UpdateField extends AstNode {
    readonly $container: UpdateFields;
    readonly $type: 'UpdateField';
    nameField: string
    valueField: string
}

export const UpdateField = 'UpdateField';

export function isUpdateField(item: unknown): item is UpdateField {
    return reflection.isInstance(item, UpdateField);
}

export interface UpdateFields extends AstNode {
    readonly $container: IncludeElement;
    readonly $type: 'UpdateFields';
    updateFields: Array<UpdateField>
}

export const UpdateFields = 'UpdateFields';

export function isUpdateFields(item: unknown): item is UpdateFields {
    return reflection.isInstance(item, UpdateFields);
}

export interface UseCase extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'UseCase';
    acceptanceCriteria: Array<AcceptanceCriteria>
    actions?: UCActions
    dataEntity?: Reference<DataEntityGeneric>
    description?: string
    extends: Array<UCExtends>
    extensionPoints?: UCExtensionPoints
    includes?: UCIncludes
    isAbstract: boolean
    isConcrete: boolean
    isNegative: boolean
    isPositive: boolean
    isProblem: boolean
    isSolution: boolean
    mainScenarios: Array<MainScenario>
    name: string
    nameAlias?: string
    postcondition?: string
    precondition?: string
    primaryActor?: Reference<Actor>
    priority?: PriorityType
    stakeholder?: Reference<Stakeholder>
    supportingActors: Array<RefActor>
    tags: Array<Tag>
    triggeredBy?: Reference<ActiveEvent>
    type: UseCaseType
}

export const UseCase = 'UseCase';

export function isUseCase(item: unknown): item is UseCase {
    return reflection.isInstance(item, UseCase);
}

export interface UseCaseTest extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'UseCaseTest';
    description?: string
    name: string
    nameAlias?: string
    scenarios: Array<TestScenario>
    tags: Array<Tag>
    type: TestType
    useCase?: Reference<UseCase>
    variables: Array<TestVariable>
}

export const UseCaseTest = 'UseCaseTest';

export function isUseCaseTest(item: unknown): item is UseCaseTest {
    return reflection.isInstance(item, UseCaseTest);
}

export interface UseCaseTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'UseCaseTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const UseCaseTypeExtended = 'UseCaseTypeExtended';

export function isUseCaseTypeExtended(item: unknown): item is UseCaseTypeExtended {
    return reflection.isInstance(item, UseCaseTypeExtended);
}

export interface UseCaseTypeExtendedRef extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'UseCaseTypeExtendedRef';
    type: Reference<UseCaseTypeExtended>
}

export const UseCaseTypeExtendedRef = 'UseCaseTypeExtendedRef';

export function isUseCaseTypeExtendedRef(item: unknown): item is UseCaseTypeExtendedRef {
    return reflection.isInstance(item, UseCaseTypeExtendedRef);
}

export interface UseCaseTypeOriginal extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'UseCaseTypeOriginal';
    type: 'EntitiesBrowse' | 'EntitiesDashboard' | 'EntitiesInteropExport' | 'EntitiesInteropImport' | 'EntitiesInteropSendMessage' | 'EntitiesInteropServiceInvocation' | 'EntitiesInteropSync' | 'EntitiesManage' | 'EntitiesMapInteract' | 'EntitiesMapShow' | 'EntitiesOther' | 'EntitiesReport' | 'EntitiesSearch' | 'EntityCreate' | 'EntityDashboard' | 'EntityDelete' | 'EntityOther' | 'EntityRead' | 'EntityReport' | 'EntityUpdate' | 'Other'
}

export const UseCaseTypeOriginal = 'UseCaseTypeOriginal';

export function isUseCaseTypeOriginal(item: unknown): item is UseCaseTypeOriginal {
    return reflection.isInstance(item, UseCaseTypeOriginal);
}

export interface UserStory extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'UserStory';
    acceptanceCriteria: Array<AcceptanceCriteria>
    actor?: Reference<Actor>
    description?: string
    goal?: string
    isAbstract: boolean
    isConcrete: boolean
    isNegative: boolean
    isPositive: boolean
    isProblem: boolean
    isSolution: boolean
    name: string
    nameAlias?: string
    otherRole?: string
    partOf?: Reference<UserStory>
    priority?: PriorityType
    reason?: string
    stakeholder?: Reference<Stakeholder>
    tags: Array<Tag>
    type: UserStoryType
}

export const UserStory = 'UserStory';

export function isUserStory(item: unknown): item is UserStory {
    return reflection.isInstance(item, UserStory);
}

export interface UserStoryTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'UserStoryTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const UserStoryTypeExtended = 'UserStoryTypeExtended';

export function isUserStoryTypeExtended(item: unknown): item is UserStoryTypeExtended {
    return reflection.isInstance(item, UserStoryTypeExtended);
}

export interface UserStoryTypeExtendedRef extends AstNode {
    readonly $container: UserStory;
    readonly $type: 'UserStoryTypeExtendedRef';
    type: Reference<UserStoryTypeExtended>
}

export const UserStoryTypeExtendedRef = 'UserStoryTypeExtendedRef';

export function isUserStoryTypeExtendedRef(item: unknown): item is UserStoryTypeExtendedRef {
    return reflection.isInstance(item, UserStoryTypeExtendedRef);
}

export interface UserStoryTypeOriginal extends AstNode {
    readonly $container: UserStory;
    readonly $type: 'UserStoryTypeOriginal';
    type: 'Epic' | 'Other' | 'UserStory'
}

export const UserStoryTypeOriginal = 'UserStoryTypeOriginal';

export function isUserStoryTypeOriginal(item: unknown): item is UserStoryTypeOriginal {
    return reflection.isInstance(item, UserStoryTypeOriginal);
}

export interface View extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'View';
    description?: string
    elements: ReferenceElements
    name: string
    nameAlias?: string
    tags: Array<Tag>
    type: ViewType
}

export const View = 'View';

export function isView(item: unknown): item is View {
    return reflection.isInstance(item, View);
}

export interface ViewType extends AstNode {
    readonly $container: View;
    readonly $type: 'ViewType';
    type: 'ActiveElementView' | 'ActorView' | 'ConstraintView' | 'DataEntityClusterView' | 'DataEntityView' | 'FRView' | 'GlossaryTermView' | 'GoalView' | 'QRView' | 'RequirementView' | 'RiskView' | 'StakeholderView' | 'TestView' | 'UseCaseView' | 'UserStoryView' | 'VulnerabilityView'
}

export const ViewType = 'ViewType';

export function isViewType(item: unknown): item is ViewType {
    return reflection.isInstance(item, ViewType);
}

export interface Vulnerability extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'Vulnerability';
    attack?: string
    attackVector?: VulnerabilityAttackVector
    description?: string
    name: string
    nameAlias?: string
    partOf?: Reference<Vulnerability>
    score?: DoubleOrInt
    solution?: RefRequirements
    subType?: VulnerabilitySubType
    super?: Reference<Vulnerability>
    tags: Array<Tag>
    type: VulnerabilityType
}

export const Vulnerability = 'Vulnerability';

export function isVulnerability(item: unknown): item is Vulnerability {
    return reflection.isInstance(item, Vulnerability);
}

export interface VulnerabilityAttackVectorExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'VulnerabilityAttackVectorExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const VulnerabilityAttackVectorExtended = 'VulnerabilityAttackVectorExtended';

export function isVulnerabilityAttackVectorExtended(item: unknown): item is VulnerabilityAttackVectorExtended {
    return reflection.isInstance(item, VulnerabilityAttackVectorExtended);
}

export interface VulnerabilityAttackVectorExtendedRef extends AstNode {
    readonly $container: Vulnerability;
    readonly $type: 'VulnerabilityAttackVectorExtendedRef';
    type: Reference<VulnerabilityAttackVectorExtended>
}

export const VulnerabilityAttackVectorExtendedRef = 'VulnerabilityAttackVectorExtendedRef';

export function isVulnerabilityAttackVectorExtendedRef(item: unknown): item is VulnerabilityAttackVectorExtendedRef {
    return reflection.isInstance(item, VulnerabilityAttackVectorExtendedRef);
}

export interface VulnerabilityAttackVectorOriginal extends AstNode {
    readonly $container: Vulnerability;
    readonly $type: 'VulnerabilityAttackVectorOriginal';
    type: 'IT_AdjacentNetwork' | 'IT_Local' | 'IT_Network' | 'IT_Other' | 'IT_Physical'
}

export const VulnerabilityAttackVectorOriginal = 'VulnerabilityAttackVectorOriginal';

export function isVulnerabilityAttackVectorOriginal(item: unknown): item is VulnerabilityAttackVectorOriginal {
    return reflection.isInstance(item, VulnerabilityAttackVectorOriginal);
}

export interface VulnerabilitySubTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'VulnerabilitySubTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const VulnerabilitySubTypeExtended = 'VulnerabilitySubTypeExtended';

export function isVulnerabilitySubTypeExtended(item: unknown): item is VulnerabilitySubTypeExtended {
    return reflection.isInstance(item, VulnerabilitySubTypeExtended);
}

export interface VulnerabilitySubTypeExtendedRef extends AstNode {
    readonly $container: Vulnerability;
    readonly $type: 'VulnerabilitySubTypeExtendedRef';
    type: Reference<VulnerabilitySubTypeExtended>
}

export const VulnerabilitySubTypeExtendedRef = 'VulnerabilitySubTypeExtendedRef';

export function isVulnerabilitySubTypeExtendedRef(item: unknown): item is VulnerabilitySubTypeExtendedRef {
    return reflection.isInstance(item, VulnerabilitySubTypeExtendedRef);
}

export interface VulnerabilitySubTypeOriginal extends AstNode {
    readonly $container: Vulnerability;
    readonly $type: 'VulnerabilitySubTypeOriginal';
    type: 'IT_BypassSomething' | 'IT_CSRF' | 'IT_CodeExecution' | 'IT_DirectoryTraversal' | 'IT_DoS' | 'IT_FileInclusion' | 'IT_GainInformation' | 'IT_GainPrivileges' | 'IT_HttpResponseSplitting' | 'IT_MemoryCorruption' | 'IT_Overflow' | 'IT_SqlInjection' | 'IT_XSS' | 'Other'
}

export const VulnerabilitySubTypeOriginal = 'VulnerabilitySubTypeOriginal';

export function isVulnerabilitySubTypeOriginal(item: unknown): item is VulnerabilitySubTypeOriginal {
    return reflection.isInstance(item, VulnerabilitySubTypeOriginal);
}

export interface VulnerabilityTypeExtended extends AstNode {
    readonly $container: System | Threat;
    readonly $type: 'VulnerabilityTypeExtended';
    description?: string
    name: string
    nameAlias?: string
}

export const VulnerabilityTypeExtended = 'VulnerabilityTypeExtended';

export function isVulnerabilityTypeExtended(item: unknown): item is VulnerabilityTypeExtended {
    return reflection.isInstance(item, VulnerabilityTypeExtended);
}

export interface VulnerabilityTypeExtendedRef extends AstNode {
    readonly $container: Vulnerability;
    readonly $type: 'VulnerabilityTypeExtendedRef';
    type: Reference<VulnerabilityTypeExtended>
}

export const VulnerabilityTypeExtendedRef = 'VulnerabilityTypeExtendedRef';

export function isVulnerabilityTypeExtendedRef(item: unknown): item is VulnerabilityTypeExtendedRef {
    return reflection.isInstance(item, VulnerabilityTypeExtendedRef);
}

export interface VulnerabilityTypeOriginal extends AstNode {
    readonly $container: Vulnerability;
    readonly $type: 'VulnerabilityTypeOriginal';
    type: 'Business' | 'IT' | 'Other' | 'Project'
}

export const VulnerabilityTypeOriginal = 'VulnerabilityTypeOriginal';

export function isVulnerabilityTypeOriginal(item: unknown): item is VulnerabilityTypeOriginal {
    return reflection.isInstance(item, VulnerabilityTypeOriginal);
}

export interface _Date extends AttributeValue {
    readonly $container: DataAttributeTableRow | _Date;
    readonly $type: '_Date';
    day: number
    month: Month
    year: number
}

export const _Date = '_Date';
export const DoubleOrInt = 'DoubleOrInt';
export const Percentage = 'Percentage';

export function is_Date(item: unknown): item is _Date {
    return reflection.isInstance(item, _Date);
}

export interface Month extends AttributeValue {
    readonly $container: DataAttributeTableRow | _Date;
    readonly $type: 'Month';
    type: 'Apr' | 'Aug' | 'Dec' | 'Feb' | 'Jan' | 'Jul' | 'Jun' | 'Mar' | 'May' | 'Nov' | 'Oct' | 'Sep'
}

export const Month = 'Month';

export function isMonth(item: unknown): item is Month {
    return reflection.isInstance(item, Month);
}

export interface DataAttributeTypeExtendedRef extends DataAttributeType {
    readonly $container: DataAttribute | TestDataAttribute;
    readonly $type: 'DataAttributeTypeExtendedRef';
    type: Reference<DataAttributeTypeExtended>
}

export const DataAttributeTypeExtendedRef = 'DataAttributeTypeExtendedRef';

export function isDataAttributeTypeExtendedRef(item: unknown): item is DataAttributeTypeExtendedRef {
    return reflection.isInstance(item, DataAttributeTypeExtendedRef);
}

export interface DataAttributeTypeOriginal extends DataAttributeType {
    readonly $container: DataAttribute | TestDataAttribute;
    readonly $type: 'DataAttributeTypeOriginal';
    type: 'Binary' | 'Bit' | 'Boolean' | 'Currency' | 'Date' | 'Datetime' | 'Decimal' | 'Double' | 'Email' | 'File' | 'FilePath' | 'Image' | 'Integer' | 'Regex' | 'String' | 'Text' | 'Time' | 'URL' | 'XML'
}

export const DataAttributeTypeOriginal = 'DataAttributeTypeOriginal';

export function isDataAttributeTypeOriginal(item: unknown): item is DataAttributeTypeOriginal {
    return reflection.isInstance(item, DataAttributeTypeOriginal);
}

export interface DataEnumerationRef extends DataAttributeType {
    readonly $container: DataAttribute | TestDataAttribute;
    readonly $type: 'DataEnumerationRef';
    type: Reference<DataEnumeration>
}

export const DataEnumerationRef = 'DataEnumerationRef';

export function isDataEnumerationRef(item: unknown): item is DataEnumerationRef {
    return reflection.isInstance(item, DataEnumerationRef);
}

export interface RslAstType {
    AcceptanceCriteria: AcceptanceCriteria
    AcceptanceCriteriaRule: AcceptanceCriteriaRule
    AcceptanceCriteriaScenario: AcceptanceCriteriaScenario
    AcceptanceCriteriaTest: AcceptanceCriteriaTest
    ActionType: ActionType
    ActionTypeExtended: ActionTypeExtended
    ActionTypeExtendedRef: ActionTypeExtendedRef
    ActionTypeOriginal: ActionTypeOriginal
    ActiveElement: ActiveElement
    ActiveEvent: ActiveEvent
    ActiveEventType: ActiveEventType
    ActiveEventTypeExtended: ActiveEventTypeExtended
    ActiveEventTypeExtendedRef: ActiveEventTypeExtendedRef
    ActiveEventTypeOriginal: ActiveEventTypeOriginal
    ActiveFlow: ActiveFlow
    ActiveFlowType: ActiveFlowType
    ActiveFlowTypeExtended: ActiveFlowTypeExtended
    ActiveFlowTypeExtendedRef: ActiveFlowTypeExtendedRef
    ActiveFlowTypeOriginal: ActiveFlowTypeOriginal
    ActiveStructureElement: ActiveStructureElement
    ActiveTask: ActiveTask
    ActiveTaskType: ActiveTaskType
    ActiveTaskTypeExtended: ActiveTaskTypeExtended
    ActiveTaskTypeExtendedRef: ActiveTaskTypeExtendedRef
    ActiveTaskTypeOriginal: ActiveTaskTypeOriginal
    Actor: Actor
    ActorType: ActorType
    ActorTypeExtended: ActorTypeExtended
    ActorTypeExtendedRef: ActorTypeExtendedRef
    ActorTypeOriginal: ActorTypeOriginal
    AttributeValue: AttributeValue
    BehaviorElement: BehaviorElement
    Check: Check
    CheckType: CheckType
    CheckTypeExtended: CheckTypeExtended
    CheckTypeExtendedRef: CheckTypeExtendedRef
    CheckTypeOriginal: CheckTypeOriginal
    ChildDataEntity: ChildDataEntity
    ConditionalExpression: ConditionalExpression
    Constraint: Constraint
    ConstraintSubType: ConstraintSubType
    ConstraintSubTypeExtended: ConstraintSubTypeExtended
    ConstraintSubTypeExtendedRef: ConstraintSubTypeExtendedRef
    ConstraintSubTypeOriginal: ConstraintSubTypeOriginal
    ConstraintType: ConstraintType
    ConstraintTypeExtended: ConstraintTypeExtended
    ConstraintTypeExtendedRef: ConstraintTypeExtendedRef
    ConstraintTypeOriginal: ConstraintTypeOriginal
    Data: Data
    DataAttribute: DataAttribute
    DataAttributeConstraint: DataAttributeConstraint
    DataAttributeRefs: DataAttributeRefs
    DataAttributeRefsList: DataAttributeRefsList
    DataAttributeTableRow: DataAttributeTableRow
    DataAttributeType: DataAttributeType
    DataAttributeTypeExtended: DataAttributeTypeExtended
    DataAttributeTypeExtendedRef: DataAttributeTypeExtendedRef
    DataAttributeTypeOriginal: DataAttributeTypeOriginal
    DataAttributeValues: DataAttributeValues
    DataEntity: DataEntity
    DataEntityCluster: DataEntityCluster
    DataEntityClusterType: DataEntityClusterType
    DataEntityClusterTypeExtended: DataEntityClusterTypeExtended
    DataEntityClusterTypeExtendedRef: DataEntityClusterTypeExtendedRef
    DataEntityClusterTypeOriginal: DataEntityClusterTypeOriginal
    DataEntityConstraint: DataEntityConstraint
    DataEntityGeneric: DataEntityGeneric
    DataEntitySubType: DataEntitySubType
    DataEntitySubTypeExtended: DataEntitySubTypeExtended
    DataEntitySubTypeExtendedRef: DataEntitySubTypeExtendedRef
    DataEntitySubTypeOriginal: DataEntitySubTypeOriginal
    DataEntityTest: DataEntityTest
    DataEntityType: DataEntityType
    DataEntityTypeExtended: DataEntityTypeExtended
    DataEntityTypeExtendedRef: DataEntityTypeExtendedRef
    DataEntityTypeOriginal: DataEntityTypeOriginal
    DataEnumeration: DataEnumeration
    DataEnumerationRef: DataEnumerationRef
    DataVariableRefs: DataVariableRefs
    DataVariableTableRow: DataVariableTableRow
    DataVariableValues: DataVariableValues
    ElementsRelation: ElementsRelation
    ElementsRelationType: ElementsRelationType
    Expression: Expression
    ExpressionOperator: ExpressionOperator
    FR: FR
    FRType: FRType
    FRTypeExtended: FRTypeExtended
    FRTypeExtendedRef: FRTypeExtendedRef
    FRTypeOriginal: FRTypeOriginal
    ForeignKey: ForeignKey
    ForeignKeyOnDeleteType: ForeignKeyOnDeleteType
    ForeignKeyOnDeleteTypeExtended: ForeignKeyOnDeleteTypeExtended
    ForeignKeyOnDeleteTypeExtendedRef: ForeignKeyOnDeleteTypeExtendedRef
    ForeignKeyOnDeleteTypeOriginal: ForeignKeyOnDeleteTypeOriginal
    GlossaryTerm: GlossaryTerm
    GlossaryTermType: GlossaryTermType
    GlossaryTermTypeExtended: GlossaryTermTypeExtended
    GlossaryTermTypeExtendedRef: GlossaryTermTypeExtendedRef
    GlossaryTermTypeOriginal: GlossaryTermTypeOriginal
    Goal: Goal
    GoalSubType: GoalSubType
    GoalSubTypeExtended: GoalSubTypeExtended
    GoalSubTypeExtendedRef: GoalSubTypeExtendedRef
    GoalSubTypeOriginal: GoalSubTypeOriginal
    GoalType: GoalType
    GoalTypeExtended: GoalTypeExtended
    GoalTypeExtendedRef: GoalTypeExtendedRef
    GoalTypeOriginal: GoalTypeOriginal
    IfExpression: IfExpression
    ImpactLevel: ImpactLevel
    Import: Import
    IncludeAll: IncludeAll
    IncludeElement: IncludeElement
    IncludeElementGeneric: IncludeElementGeneric
    IncludeSystemElementType: IncludeSystemElementType
    MainScenario: MainScenario
    ManyToMany: ManyToMany
    MetricType: MetricType
    MetricTypeExtended: MetricTypeExtended
    MetricTypeExtendedRef: MetricTypeExtendedRef
    MetricTypeOriginal: MetricTypeOriginal
    Model: Model
    Month: Month
    Multiplicity: Multiplicity
    OperationExtension: OperationExtension
    OperationTargetType: OperationTargetType
    OtherElement: OtherElement
    PackageAbstract: PackageAbstract
    PackageSystem: PackageSystem
    PassiveStructureElement: PassiveStructureElement
    PriorityType: PriorityType
    PriorityTypeExtended: PriorityTypeExtended
    PriorityTypeExtendedRef: PriorityTypeExtendedRef
    PriorityTypeOriginal: PriorityTypeOriginal
    QR: QR
    QRSubType: QRSubType
    QRSubTypeExtended: QRSubTypeExtended
    QRSubTypeExtendedRef: QRSubTypeExtendedRef
    QRSubTypeOriginal: QRSubTypeOriginal
    QRType: QRType
    QRTypeExtended: QRTypeExtended
    QRTypeExtendedRef: QRTypeExtendedRef
    QRTypeOriginal: QRTypeOriginal
    RefActiveElement: RefActiveElement
    RefActor: RefActor
    RefDataEntity: RefDataEntity
    RefRequirements: RefRequirements
    RefSystems: RefSystems
    RefTermApplicableTo: RefTermApplicableTo
    RefUC: RefUC
    RefUCAction: RefUCAction
    ReferenceElements: ReferenceElements
    RelationType: RelationType
    RelationTypeExtended: RelationTypeExtended
    RelationTypeExtendedRef: RelationTypeExtendedRef
    RelationTypeOriginal: RelationTypeOriginal
    RepeatExpression: RepeatExpression
    Requirement: Requirement
    RequirementsRelation: RequirementsRelation
    RequirementsRelationType: RequirementsRelationType
    RequirementsRelationTypeExtended: RequirementsRelationTypeExtended
    RequirementsRelationTypeExtendedRef: RequirementsRelationTypeExtendedRef
    RequirementsRelationTypeOriginal: RequirementsRelationTypeOriginal
    Risk: Risk
    RiskAssessment: RiskAssessment
    RiskGeneric: RiskGeneric
    RiskStatus: RiskStatus
    RiskSubType: RiskSubType
    RiskSubTypeExtended: RiskSubTypeExtended
    RiskSubTypeExtendedRef: RiskSubTypeExtendedRef
    RiskSubTypeOriginal: RiskSubTypeOriginal
    RiskTreatment: RiskTreatment
    RiskTreatmentType: RiskTreatmentType
    RiskTreatmentTypeExtended: RiskTreatmentTypeExtended
    RiskTreatmentTypeExtendedRef: RiskTreatmentTypeExtendedRef
    RiskTreatmentTypeOriginal: RiskTreatmentTypeOriginal
    RiskType: RiskType
    RiskTypeExtended: RiskTypeExtended
    RiskTypeExtendedRef: RiskTypeExtendedRef
    RiskTypeOriginal: RiskTypeOriginal
    Scenario: Scenario
    ScenarioType: ScenarioType
    ScenarioTypeExtended: ScenarioTypeExtended
    ScenarioTypeExtendedRef: ScenarioTypeExtendedRef
    ScenarioTypeOriginal: ScenarioTypeOriginal
    SimpleTestStep: SimpleTestStep
    Stakeholder: Stakeholder
    StakeholderSubType: StakeholderSubType
    StakeholderSubTypeExtended: StakeholderSubTypeExtended
    StakeholderSubTypeExtendedRef: StakeholderSubTypeExtendedRef
    StakeholderSubTypeOriginal: StakeholderSubTypeOriginal
    StakeholderType: StakeholderType
    StakeholderTypeExtended: StakeholderTypeExtended
    StakeholderTypeExtendedRef: StakeholderTypeExtendedRef
    StakeholderTypeOriginal: StakeholderTypeOriginal
    State: State
    StateMachine: StateMachine
    StateMachineTest: StateMachineTest
    StateMachineType: StateMachineType
    StateMachineTypeExtended: StateMachineTypeExtended
    StateMachineTypeExtendedRef: StateMachineTypeExtendedRef
    StateMachineTypeOriginal: StateMachineTypeOriginal
    StateSequence: StateSequence
    States: States
    Step: Step
    StepOperationUCType: StepOperationUCType
    StepSubSubType: StepSubSubType
    StepSubSubTypeExtended: StepSubSubTypeExtended
    StepSubSubTypeExtendedRef: StepSubSubTypeExtendedRef
    StepSubSubTypeOriginal: StepSubSubTypeOriginal
    StepSubType: StepSubType
    StepSubTypeExtended: StepSubTypeExtended
    StepSubTypeExtendedRef: StepSubTypeExtendedRef
    StepSubTypeOriginal: StepSubTypeOriginal
    StepType: StepType
    StepTypeExtended: StepTypeExtended
    StepTypeExtendedRef: StepTypeExtendedRef
    StepTypeOriginal: StepTypeOriginal
    Stereotype: Stereotype
    StereotypeType: StereotypeType
    StereotypeTypeExtended: StereotypeTypeExtended
    StereotypeTypeExtendedRef: StereotypeTypeExtendedRef
    StereotypeTypeOriginal: StereotypeTypeOriginal
    StructureElement: StructureElement
    System: System
    SystemConcept: SystemConcept
    SystemElement: SystemElement
    SystemRelation: SystemRelation
    SystemSet: SystemSet
    SystemSubType: SystemSubType
    SystemSubTypeExtended: SystemSubTypeExtended
    SystemSubTypeExtendedRef: SystemSubTypeExtendedRef
    SystemSubTypeOriginal: SystemSubTypeOriginal
    SystemType: SystemType
    SystemTypeExtended: SystemTypeExtended
    SystemTypeExtendedRef: SystemTypeExtendedRef
    SystemTypeOriginal: SystemTypeOriginal
    SystemsRelation: SystemsRelation
    SystemsRelationCategory: SystemsRelationCategory
    SystemsRelationCategoryExtended: SystemsRelationCategoryExtended
    SystemsRelationCategoryExtendedRef: SystemsRelationCategoryExtendedRef
    SystemsRelationCategoryOriginal: SystemsRelationCategoryOriginal
    SystemsRelationType: SystemsRelationType
    SystemsRelationTypeExtended: SystemsRelationTypeExtended
    SystemsRelationTypeExtendedRef: SystemsRelationTypeExtendedRef
    SystemsRelationTypeOriginal: SystemsRelationTypeOriginal
    Tag: Tag
    TermApplicableTo: TermApplicableTo
    Test: Test
    TestCheck: TestCheck
    TestDataAttribute: TestDataAttribute
    TestOperationTarget: TestOperationTarget
    TestScenario: TestScenario
    TestScenarioType: TestScenarioType
    TestScenarioTypeExtended: TestScenarioTypeExtended
    TestScenarioTypeExtendedRef: TestScenarioTypeExtendedRef
    TestScenarioTypeOriginal: TestScenarioTypeOriginal
    TestStep: TestStep
    TestType: TestType
    TestTypeExtended: TestTypeExtended
    TestTypeExtendedRef: TestTypeExtendedRef
    TestTypeOriginal: TestTypeOriginal
    TestVariable: TestVariable
    TestsRelation: TestsRelation
    TestsRelationType: TestsRelationType
    TestsRelationTypeExtended: TestsRelationTypeExtended
    TestsRelationTypeExtendedRef: TestsRelationTypeExtendedRef
    TestsRelationTypeOriginal: TestsRelationTypeOriginal
    Theme: Theme
    ThemeType: ThemeType
    Threat: Threat
    Transition: Transition
    TypeExtended: TypeExtended
    UCActions: UCActions
    UCExtends: UCExtends
    UCExtensionPoint: UCExtensionPoint
    UCExtensionPoints: UCExtensionPoints
    UCIncludes: UCIncludes
    UpdateField: UpdateField
    UpdateFields: UpdateFields
    UseCase: UseCase
    UseCaseTest: UseCaseTest
    UseCaseType: UseCaseType
    UseCaseTypeExtended: UseCaseTypeExtended
    UseCaseTypeExtendedRef: UseCaseTypeExtendedRef
    UseCaseTypeOriginal: UseCaseTypeOriginal
    UserStory: UserStory
    UserStoryType: UserStoryType
    UserStoryTypeExtended: UserStoryTypeExtended
    UserStoryTypeExtendedRef: UserStoryTypeExtendedRef
    UserStoryTypeOriginal: UserStoryTypeOriginal
    View: View
    ViewType: ViewType
    Vulnerability: Vulnerability
    VulnerabilityAttackVector: VulnerabilityAttackVector
    VulnerabilityAttackVectorExtended: VulnerabilityAttackVectorExtended
    VulnerabilityAttackVectorExtendedRef: VulnerabilityAttackVectorExtendedRef
    VulnerabilityAttackVectorOriginal: VulnerabilityAttackVectorOriginal
    VulnerabilitySubType: VulnerabilitySubType
    VulnerabilitySubTypeExtended: VulnerabilitySubTypeExtended
    VulnerabilitySubTypeExtendedRef: VulnerabilitySubTypeExtendedRef
    VulnerabilitySubTypeOriginal: VulnerabilitySubTypeOriginal
    VulnerabilityType: VulnerabilityType
    VulnerabilityTypeExtended: VulnerabilityTypeExtended
    VulnerabilityTypeExtendedRef: VulnerabilityTypeExtendedRef
    VulnerabilityTypeOriginal: VulnerabilityTypeOriginal
    _Date: _Date
}

export class RslAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AcceptanceCriteria', 'AcceptanceCriteriaRule', 'AcceptanceCriteriaScenario', 'AcceptanceCriteriaTest', 'ActionType', 'ActionTypeExtended', 'ActionTypeExtendedRef', 'ActionTypeOriginal', 'ActiveElement', 'ActiveEvent', 'ActiveEventType', 'ActiveEventTypeExtended', 'ActiveEventTypeExtendedRef', 'ActiveEventTypeOriginal', 'ActiveFlow', 'ActiveFlowType', 'ActiveFlowTypeExtended', 'ActiveFlowTypeExtendedRef', 'ActiveFlowTypeOriginal', 'ActiveStructureElement', 'ActiveTask', 'ActiveTaskType', 'ActiveTaskTypeExtended', 'ActiveTaskTypeExtendedRef', 'ActiveTaskTypeOriginal', 'Actor', 'ActorType', 'ActorTypeExtended', 'ActorTypeExtendedRef', 'ActorTypeOriginal', 'AttributeValue', 'BehaviorElement', 'Check', 'CheckType', 'CheckTypeExtended', 'CheckTypeExtendedRef', 'CheckTypeOriginal', 'ChildDataEntity', 'ConditionalExpression', 'Constraint', 'ConstraintSubType', 'ConstraintSubTypeExtended', 'ConstraintSubTypeExtendedRef', 'ConstraintSubTypeOriginal', 'ConstraintType', 'ConstraintTypeExtended', 'ConstraintTypeExtendedRef', 'ConstraintTypeOriginal', 'Data', 'DataAttribute', 'DataAttributeConstraint', 'DataAttributeRefs', 'DataAttributeRefsList', 'DataAttributeTableRow', 'DataAttributeType', 'DataAttributeTypeExtended', 'DataAttributeTypeExtendedRef', 'DataAttributeTypeOriginal', 'DataAttributeValues', 'DataEntity', 'DataEntityCluster', 'DataEntityClusterType', 'DataEntityClusterTypeExtended', 'DataEntityClusterTypeExtendedRef', 'DataEntityClusterTypeOriginal', 'DataEntityConstraint', 'DataEntityGeneric', 'DataEntitySubType', 'DataEntitySubTypeExtended', 'DataEntitySubTypeExtendedRef', 'DataEntitySubTypeOriginal', 'DataEntityTest', 'DataEntityType', 'DataEntityTypeExtended', 'DataEntityTypeExtendedRef', 'DataEntityTypeOriginal', 'DataEnumeration', 'DataEnumerationRef', 'DataVariableRefs', 'DataVariableTableRow', 'DataVariableValues', 'ElementsRelation', 'ElementsRelationType', 'Expression', 'ExpressionOperator', 'FR', 'FRType', 'FRTypeExtended', 'FRTypeExtendedRef', 'FRTypeOriginal', 'ForeignKey', 'ForeignKeyOnDeleteType', 'ForeignKeyOnDeleteTypeExtended', 'ForeignKeyOnDeleteTypeExtendedRef', 'ForeignKeyOnDeleteTypeOriginal', 'GlossaryTerm', 'GlossaryTermType', 'GlossaryTermTypeExtended', 'GlossaryTermTypeExtendedRef', 'GlossaryTermTypeOriginal', 'Goal', 'GoalSubType', 'GoalSubTypeExtended', 'GoalSubTypeExtendedRef', 'GoalSubTypeOriginal', 'GoalType', 'GoalTypeExtended', 'GoalTypeExtendedRef', 'GoalTypeOriginal', 'IfExpression', 'ImpactLevel', 'Import', 'IncludeAll', 'IncludeElement', 'IncludeElementGeneric', 'IncludeSystemElementType', 'MainScenario', 'ManyToMany', 'MetricType', 'MetricTypeExtended', 'MetricTypeExtendedRef', 'MetricTypeOriginal', 'Model', 'Month', 'Multiplicity', 'OperationExtension', 'OperationTargetType', 'OtherElement', 'PackageAbstract', 'PackageSystem', 'PassiveStructureElement', 'PriorityType', 'PriorityTypeExtended', 'PriorityTypeExtendedRef', 'PriorityTypeOriginal', 'QR', 'QRSubType', 'QRSubTypeExtended', 'QRSubTypeExtendedRef', 'QRSubTypeOriginal', 'QRType', 'QRTypeExtended', 'QRTypeExtendedRef', 'QRTypeOriginal', 'RefActiveElement', 'RefActor', 'RefDataEntity', 'RefRequirements', 'RefSystems', 'RefTermApplicableTo', 'RefUC', 'RefUCAction', 'ReferenceElements', 'RelationType', 'RelationTypeExtended', 'RelationTypeExtendedRef', 'RelationTypeOriginal', 'RepeatExpression', 'Requirement', 'RequirementsRelation', 'RequirementsRelationType', 'RequirementsRelationTypeExtended', 'RequirementsRelationTypeExtendedRef', 'RequirementsRelationTypeOriginal', 'Risk', 'RiskAssessment', 'RiskGeneric', 'RiskStatus', 'RiskSubType', 'RiskSubTypeExtended', 'RiskSubTypeExtendedRef', 'RiskSubTypeOriginal', 'RiskTreatment', 'RiskTreatmentType', 'RiskTreatmentTypeExtended', 'RiskTreatmentTypeExtendedRef', 'RiskTreatmentTypeOriginal', 'RiskType', 'RiskTypeExtended', 'RiskTypeExtendedRef', 'RiskTypeOriginal', 'Scenario', 'ScenarioType', 'ScenarioTypeExtended', 'ScenarioTypeExtendedRef', 'ScenarioTypeOriginal', 'SimpleTestStep', 'Stakeholder', 'StakeholderSubType', 'StakeholderSubTypeExtended', 'StakeholderSubTypeExtendedRef', 'StakeholderSubTypeOriginal', 'StakeholderType', 'StakeholderTypeExtended', 'StakeholderTypeExtendedRef', 'StakeholderTypeOriginal', 'State', 'StateMachine', 'StateMachineTest', 'StateMachineType', 'StateMachineTypeExtended', 'StateMachineTypeExtendedRef', 'StateMachineTypeOriginal', 'StateSequence', 'States', 'Step', 'StepOperationUCType', 'StepSubSubType', 'StepSubSubTypeExtended', 'StepSubSubTypeExtendedRef', 'StepSubSubTypeOriginal', 'StepSubType', 'StepSubTypeExtended', 'StepSubTypeExtendedRef', 'StepSubTypeOriginal', 'StepType', 'StepTypeExtended', 'StepTypeExtendedRef', 'StepTypeOriginal', 'Stereotype', 'StereotypeType', 'StereotypeTypeExtended', 'StereotypeTypeExtendedRef', 'StereotypeTypeOriginal', 'StructureElement', 'System', 'SystemConcept', 'SystemElement', 'SystemRelation', 'SystemSet', 'SystemSubType', 'SystemSubTypeExtended', 'SystemSubTypeExtendedRef', 'SystemSubTypeOriginal', 'SystemType', 'SystemTypeExtended', 'SystemTypeExtendedRef', 'SystemTypeOriginal', 'SystemsRelation', 'SystemsRelationCategory', 'SystemsRelationCategoryExtended', 'SystemsRelationCategoryExtendedRef', 'SystemsRelationCategoryOriginal', 'SystemsRelationType', 'SystemsRelationTypeExtended', 'SystemsRelationTypeExtendedRef', 'SystemsRelationTypeOriginal', 'Tag', 'TermApplicableTo', 'Test', 'TestCheck', 'TestDataAttribute', 'TestOperationTarget', 'TestScenario', 'TestScenarioType', 'TestScenarioTypeExtended', 'TestScenarioTypeExtendedRef', 'TestScenarioTypeOriginal', 'TestStep', 'TestType', 'TestTypeExtended', 'TestTypeExtendedRef', 'TestTypeOriginal', 'TestVariable', 'TestsRelation', 'TestsRelationType', 'TestsRelationTypeExtended', 'TestsRelationTypeExtendedRef', 'TestsRelationTypeOriginal', 'Theme', 'ThemeType', 'Threat', 'Transition', 'TypeExtended', 'UCActions', 'UCExtends', 'UCExtensionPoint', 'UCExtensionPoints', 'UCIncludes', 'UpdateField', 'UpdateFields', 'UseCase', 'UseCaseTest', 'UseCaseType', 'UseCaseTypeExtended', 'UseCaseTypeExtendedRef', 'UseCaseTypeOriginal', 'UserStory', 'UserStoryType', 'UserStoryTypeExtended', 'UserStoryTypeExtendedRef', 'UserStoryTypeOriginal', 'View', 'ViewType', 'Vulnerability', 'VulnerabilityAttackVector', 'VulnerabilityAttackVectorExtended', 'VulnerabilityAttackVectorExtendedRef', 'VulnerabilityAttackVectorOriginal', 'VulnerabilitySubType', 'VulnerabilitySubTypeExtended', 'VulnerabilitySubTypeExtendedRef', 'VulnerabilitySubTypeOriginal', 'VulnerabilityType', 'VulnerabilityTypeExtended', 'VulnerabilityTypeExtendedRef', 'VulnerabilityTypeOriginal', '_Date'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case _Date:
            case DoubleOrInt:
            case Month:
            case Percentage: {
                return this.isSubtype(AttributeValue, supertype);
            }
            case AcceptanceCriteriaTest:
            case DataEntityTest:
            case StateMachineTest:
            case UseCaseTest: {
                return this.isSubtype(Test, supertype);
            }
            case ActionTypeExtended:
            case ActiveEventTypeExtended:
            case ActiveFlowTypeExtended:
            case ActiveTaskTypeExtended:
            case ActorTypeExtended:
            case CheckTypeExtended:
            case ConstraintSubTypeExtended:
            case ConstraintTypeExtended:
            case DataAttributeTypeExtended:
            case DataEntityClusterTypeExtended:
            case DataEntitySubTypeExtended:
            case DataEntityTypeExtended:
            case ForeignKeyOnDeleteTypeExtended:
            case FRTypeExtended:
            case GlossaryTermTypeExtended:
            case GoalSubTypeExtended:
            case GoalTypeExtended:
            case MetricTypeExtended:
            case PriorityTypeExtended:
            case QRSubTypeExtended:
            case QRTypeExtended:
            case RelationTypeExtended:
            case RequirementsRelationTypeExtended:
            case RiskSubTypeExtended:
            case RiskTreatmentTypeExtended:
            case RiskTypeExtended:
            case ScenarioTypeExtended:
            case StakeholderSubTypeExtended:
            case StakeholderTypeExtended:
            case StateMachineTypeExtended:
            case StepSubSubTypeExtended:
            case StepSubTypeExtended:
            case StepTypeExtended:
            case StereotypeTypeExtended:
            case SystemsRelationCategoryExtended:
            case SystemsRelationTypeExtended:
            case SystemSubTypeExtended:
            case SystemTypeExtended:
            case TestScenarioTypeExtended:
            case TestsRelationTypeExtended:
            case TestTypeExtended:
            case UseCaseTypeExtended:
            case UserStoryTypeExtended:
            case VulnerabilityAttackVectorExtended:
            case VulnerabilitySubTypeExtended:
            case VulnerabilityTypeExtended: {
                return this.isSubtype(TypeExtended, supertype);
            }
            case ActionTypeExtendedRef:
            case ActionTypeOriginal: {
                return this.isSubtype(ActionType, supertype);
            }
            case ActiveElement:
            case StateMachine: {
                return this.isSubtype(BehaviorElement, supertype);
            }
            case ActiveEvent:
            case ActiveFlow:
            case ActiveTask: {
                return this.isSubtype(ActiveElement, supertype);
            }
            case ActiveEventTypeExtendedRef:
            case ActiveEventTypeOriginal: {
                return this.isSubtype(ActiveEventType, supertype);
            }
            case ActiveFlowTypeExtendedRef:
            case ActiveFlowTypeOriginal: {
                return this.isSubtype(ActiveFlowType, supertype);
            }
            case ActiveStructureElement:
            case PassiveStructureElement: {
                return this.isSubtype(StructureElement, supertype);
            }
            case ActiveTaskTypeExtendedRef:
            case ActiveTaskTypeOriginal: {
                return this.isSubtype(ActiveTaskType, supertype);
            }
            case Actor:
            case Stakeholder: {
                return this.isSubtype(ActiveStructureElement, supertype);
            }
            case ActorTypeExtendedRef:
            case ActorTypeOriginal: {
                return this.isSubtype(ActorType, supertype);
            }
            case BehaviorElement:
            case IncludeElementGeneric:
            case OtherElement:
            case Requirement:
            case StructureElement:
            case Test: {
                return this.isSubtype(SystemElement, supertype);
            }
            case CheckTypeExtendedRef:
            case CheckTypeOriginal: {
                return this.isSubtype(CheckType, supertype);
            }
            case Constraint:
            case FR:
            case Goal:
            case QR:
            case UseCase:
            case UserStory: {
                return this.isSubtype(Requirement, supertype);
            }
            case ConstraintSubTypeExtendedRef:
            case ConstraintSubTypeOriginal: {
                return this.isSubtype(ConstraintSubType, supertype);
            }
            case ConstraintTypeExtendedRef:
            case ConstraintTypeOriginal: {
                return this.isSubtype(ConstraintType, supertype);
            }
            case Data:
            case DataEntityGeneric:
            case DataEnumeration: {
                return this.isSubtype(PassiveStructureElement, supertype);
            }
            case DataAttributeTypeExtendedRef:
            case DataAttributeTypeOriginal:
            case DataEnumerationRef: {
                return this.isSubtype(DataAttributeType, supertype);
            }
            case DataEntity:
            case DataEntityCluster: {
                return this.isSubtype(DataEntityGeneric, supertype);
            }
            case DataEntityClusterTypeExtendedRef:
            case DataEntityClusterTypeOriginal: {
                return this.isSubtype(DataEntityClusterType, supertype);
            }
            case DataEntitySubTypeExtendedRef:
            case DataEntitySubTypeOriginal: {
                return this.isSubtype(DataEntitySubType, supertype);
            }
            case DataEntityTypeExtendedRef:
            case DataEntityTypeOriginal: {
                return this.isSubtype(DataEntityType, supertype);
            }
            case ElementsRelation:
            case RequirementsRelation:
            case SystemsRelation:
            case TestsRelation: {
                return this.isSubtype(SystemRelation, supertype);
            }
            case ForeignKeyOnDeleteTypeExtendedRef:
            case ForeignKeyOnDeleteTypeOriginal: {
                return this.isSubtype(ForeignKeyOnDeleteType, supertype);
            }
            case FRTypeExtendedRef:
            case FRTypeOriginal: {
                return this.isSubtype(FRType, supertype);
            }
            case GlossaryTerm:
            case RiskGeneric:
            case Stereotype:
            case TypeExtended: {
                return this.isSubtype(OtherElement, supertype);
            }
            case GlossaryTermTypeExtendedRef:
            case GlossaryTermTypeOriginal: {
                return this.isSubtype(GlossaryTermType, supertype);
            }
            case GoalSubTypeExtendedRef:
            case GoalSubTypeOriginal: {
                return this.isSubtype(GoalSubType, supertype);
            }
            case GoalTypeExtendedRef:
            case GoalTypeOriginal: {
                return this.isSubtype(GoalType, supertype);
            }
            case IfExpression:
            case RepeatExpression: {
                return this.isSubtype(ConditionalExpression, supertype);
            }
            case IncludeAll:
            case IncludeElement: {
                return this.isSubtype(IncludeElementGeneric, supertype);
            }
            case MetricTypeExtendedRef:
            case MetricTypeOriginal: {
                return this.isSubtype(MetricType, supertype);
            }
            case PackageSystem: {
                return this.isSubtype(PackageAbstract, supertype);
            }
            case PriorityTypeExtendedRef:
            case PriorityTypeOriginal: {
                return this.isSubtype(PriorityType, supertype);
            }
            case QRSubTypeExtendedRef:
            case QRSubTypeOriginal: {
                return this.isSubtype(QRSubType, supertype);
            }
            case QRTypeExtendedRef:
            case QRTypeOriginal: {
                return this.isSubtype(QRType, supertype);
            }
            case RelationTypeExtendedRef:
            case RelationTypeOriginal: {
                return this.isSubtype(RelationType, supertype);
            }
            case RequirementsRelationTypeExtendedRef:
            case RequirementsRelationTypeOriginal: {
                return this.isSubtype(RequirementsRelationType, supertype);
            }
            case Risk:
            case Vulnerability: {
                return this.isSubtype(RiskGeneric, supertype);
            }
            case RiskSubTypeExtendedRef:
            case RiskSubTypeOriginal: {
                return this.isSubtype(RiskSubType, supertype);
            }
            case RiskTreatmentTypeExtendedRef:
            case RiskTreatmentTypeOriginal: {
                return this.isSubtype(RiskTreatmentType, supertype);
            }
            case RiskTypeExtendedRef:
            case RiskTypeOriginal: {
                return this.isSubtype(RiskType, supertype);
            }
            case ScenarioTypeExtendedRef:
            case ScenarioTypeOriginal: {
                return this.isSubtype(ScenarioType, supertype);
            }
            case StakeholderSubTypeExtendedRef:
            case StakeholderSubTypeOriginal: {
                return this.isSubtype(StakeholderSubType, supertype);
            }
            case StakeholderTypeExtendedRef:
            case StakeholderTypeOriginal: {
                return this.isSubtype(StakeholderType, supertype);
            }
            case State: {
                return this.isSubtype(States, supertype);
            }
            case StateMachineTypeExtendedRef:
            case StateMachineTypeOriginal: {
                return this.isSubtype(StateMachineType, supertype);
            }
            case StepSubSubTypeExtendedRef:
            case StepSubSubTypeOriginal: {
                return this.isSubtype(StepSubSubType, supertype);
            }
            case StepSubTypeExtendedRef:
            case StepSubTypeOriginal: {
                return this.isSubtype(StepSubType, supertype);
            }
            case StepTypeExtendedRef:
            case StepTypeOriginal: {
                return this.isSubtype(StepType, supertype);
            }
            case StereotypeTypeExtendedRef:
            case StereotypeTypeOriginal: {
                return this.isSubtype(StereotypeType, supertype);
            }
            case SystemElement:
            case SystemRelation:
            case SystemSet: {
                return this.isSubtype(SystemConcept, supertype);
            }
            case SystemsRelationCategoryExtendedRef:
            case SystemsRelationCategoryOriginal: {
                return this.isSubtype(SystemsRelationCategory, supertype);
            }
            case SystemsRelationTypeExtendedRef:
            case SystemsRelationTypeOriginal: {
                return this.isSubtype(SystemsRelationType, supertype);
            }
            case SystemSubTypeExtendedRef:
            case SystemSubTypeOriginal: {
                return this.isSubtype(SystemSubType, supertype);
            }
            case SystemTypeExtendedRef:
            case SystemTypeOriginal: {
                return this.isSubtype(SystemType, supertype);
            }
            case TestScenarioTypeExtendedRef:
            case TestScenarioTypeOriginal: {
                return this.isSubtype(TestScenarioType, supertype);
            }
            case TestsRelationTypeExtendedRef:
            case TestsRelationTypeOriginal: {
                return this.isSubtype(TestsRelationType, supertype);
            }
            case TestTypeExtendedRef:
            case TestTypeOriginal: {
                return this.isSubtype(TestType, supertype);
            }
            case Theme:
            case View: {
                return this.isSubtype(SystemSet, supertype);
            }
            case UseCaseTypeExtendedRef:
            case UseCaseTypeOriginal: {
                return this.isSubtype(UseCaseType, supertype);
            }
            case UserStoryTypeExtendedRef:
            case UserStoryTypeOriginal: {
                return this.isSubtype(UserStoryType, supertype);
            }
            case VulnerabilityAttackVectorExtendedRef:
            case VulnerabilityAttackVectorOriginal: {
                return this.isSubtype(VulnerabilityAttackVector, supertype);
            }
            case VulnerabilitySubTypeExtendedRef:
            case VulnerabilitySubTypeOriginal: {
                return this.isSubtype(VulnerabilitySubType, supertype);
            }
            case VulnerabilityTypeExtendedRef:
            case VulnerabilityTypeOriginal: {
                return this.isSubtype(VulnerabilityType, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'AcceptanceCriteriaTest:requirement':
            case 'RefRequirements:refs':
            case 'RequirementsRelation:source':
            case 'RequirementsRelation:target':
            case 'Risk:negativeRequirement': {
                return Requirement;
            }
            case 'ActionTypeExtendedRef:type': {
                return ActionTypeExtended;
            }
            case 'ActiveEvent:stakeholder':
            case 'ActiveTask:participant':
            case 'ActiveTask:participantTarget':
            case 'Actor:stakeholder':
            case 'Constraint:stakeholder':
            case 'FR:stakeholder':
            case 'Goal:stakeholder':
            case 'QR:stakeholder':
            case 'RiskTreatment:owner':
            case 'Stakeholder:partOf':
            case 'Stakeholder:super':
            case 'UseCase:stakeholder':
            case 'UserStory:stakeholder': {
                return Stakeholder;
            }
            case 'ActiveEventTypeExtendedRef:type': {
                return ActiveEventTypeExtended;
            }
            case 'ActiveFlowTypeExtendedRef:type': {
                return ActiveFlowTypeExtended;
            }
            case 'ActiveTask:partOf': {
                return ActiveTask;
            }
            case 'ActiveTaskTypeExtendedRef:type': {
                return ActiveTaskTypeExtended;
            }
            case 'Actor:super':
            case 'RefActor:refs':
            case 'SimpleTestStep:actor':
            case 'Step:actor':
            case 'TestStep:actor':
            case 'UseCase:primaryActor':
            case 'UserStory:actor': {
                return Actor;
            }
            case 'ActorTypeExtendedRef:type': {
                return ActorTypeExtended;
            }
            case 'CheckTypeExtendedRef:type': {
                return CheckTypeExtended;
            }
            case 'ChildDataEntity:child':
            case 'DataEntity:super':
            case 'DataEntityCluster:main':
            case 'DataEntityTest:entity':
            case 'ForeignKey:targetEntity':
            case 'ManyToMany:targetEntity':
            case 'ManyToMany:throughEntity':
            case 'RefDataEntity:refDataEntity':
            case 'TestScenario:entity': {
                return DataEntity;
            }
            case 'Constraint:partOf': {
                return Constraint;
            }
            case 'ConstraintSubTypeExtendedRef:type': {
                return ConstraintSubTypeExtended;
            }
            case 'ConstraintTypeExtendedRef:type': {
                return ConstraintTypeExtended;
            }
            case 'Data:type':
            case 'StateMachine:entity':
            case 'UseCase:dataEntity': {
                return DataEntityGeneric;
            }
            case 'DataAttributeRefs:attributeRef':
            case 'DataAttributeRefsList:attributeRef':
            case 'DataEntityConstraint:showAsAttribute':
            case 'DataVariableRefs:variableRef':
            case 'ForeignKey:showAsField':
            case 'ForeignKey:toField':
            case 'ManyToMany:throughSourceField':
            case 'ManyToMany:throughTargetField':
            case 'TestCheck:codeVariable':
            case 'TestCheck:expected':
            case 'TestCheck:limitVariable':
            case 'TestCheck:textVariable':
            case 'TestCheck:timeoutVariable':
            case 'TestCheck:urlVariable':
            case 'TestCheck:variable':
            case 'TestDataAttribute:attribute':
            case 'TestOperationTarget:variable': {
                return DataAttribute;
            }
            case 'DataAttributeTypeExtendedRef:type': {
                return DataAttributeTypeExtended;
            }
            case 'DataEntityClusterTypeExtendedRef:type': {
                return DataEntityClusterTypeExtended;
            }
            case 'DataEntitySubTypeExtendedRef:type': {
                return DataEntitySubTypeExtended;
            }
            case 'DataEntityTypeExtendedRef:type': {
                return DataEntityTypeExtended;
            }
            case 'DataEnumerationRef:type': {
                return DataEnumeration;
            }
            case 'ElementsRelation:source':
            case 'ElementsRelation:target':
            case 'IncludeElement:element':
            case 'ReferenceElements:references': {
                return SystemElement;
            }
            case 'ForeignKeyOnDeleteTypeExtendedRef:type': {
                return ForeignKeyOnDeleteTypeExtended;
            }
            case 'FR:partOf': {
                return FR;
            }
            case 'FRTypeExtendedRef:type': {
                return FRTypeExtended;
            }
            case 'GlossaryTerm:partOf':
            case 'GlossaryTerm:super': {
                return GlossaryTerm;
            }
            case 'GlossaryTermTypeExtendedRef:type': {
                return GlossaryTermTypeExtended;
            }
            case 'Goal:partOf': {
                return Goal;
            }
            case 'GoalSubTypeExtendedRef:type': {
                return GoalSubTypeExtended;
            }
            case 'GoalTypeExtendedRef:type': {
                return GoalTypeExtended;
            }
            case 'IncludeAll:system':
            case 'IncludeElement:system':
            case 'RefSystems:refs':
            case 'System:partOf':
            case 'System:sut':
            case 'SystemsRelation:source':
            case 'SystemsRelation:target': {
                return System;
            }
            case 'MetricTypeExtendedRef:type': {
                return MetricTypeExtended;
            }
            case 'PriorityTypeExtendedRef:type': {
                return PriorityTypeExtended;
            }
            case 'QR:partOf': {
                return QR;
            }
            case 'QRSubTypeExtendedRef:type': {
                return QRSubTypeExtended;
            }
            case 'QRTypeExtendedRef:type': {
                return QRTypeExtended;
            }
            case 'RefActiveElement:refActiveElement': {
                return ActiveElement;
            }
            case 'RefUC:refs':
            case 'RefUCAction:useCase':
            case 'Step:usecase':
            case 'UCExtends:usecase':
            case 'UseCaseTest:useCase': {
                return UseCase;
            }
            case 'RelationTypeExtendedRef:type': {
                return RelationTypeExtended;
            }
            case 'RequirementsRelationTypeExtendedRef:type': {
                return RequirementsRelationTypeExtended;
            }
            case 'Risk:partOf': {
                return Risk;
            }
            case 'Risk:refVulnerabilities':
            case 'Vulnerability:partOf':
            case 'Vulnerability:super': {
                return Vulnerability;
            }
            case 'RiskSubTypeExtendedRef:type': {
                return RiskSubTypeExtended;
            }
            case 'RiskTreatmentTypeExtendedRef:type': {
                return RiskTreatmentTypeExtended;
            }
            case 'RiskTypeExtendedRef:type': {
                return RiskTypeExtended;
            }
            case 'ScenarioTypeExtendedRef:type': {
                return ScenarioTypeExtended;
            }
            case 'SimpleTestStep:next': {
                return TestStep;
            }
            case 'StakeholderSubTypeExtendedRef:type': {
                return StakeholderSubTypeExtended;
            }
            case 'StakeholderTypeExtendedRef:type': {
                return StakeholderTypeExtended;
            }
            case 'StateMachineTest:stateMachine': {
                return StateMachine;
            }
            case 'StateMachineTypeExtendedRef:type': {
                return StateMachineTypeExtended;
            }
            case 'StateSequence:refState':
            case 'Transition:nextstate': {
                return State;
            }
            case 'Step:next':
            case 'TestStep:next': {
                return Step;
            }
            case 'StepSubSubTypeExtendedRef:type': {
                return StepSubSubTypeExtended;
            }
            case 'StepSubTypeExtendedRef:type': {
                return StepSubTypeExtended;
            }
            case 'StepTypeExtendedRef:type': {
                return StepTypeExtended;
            }
            case 'StereotypeTypeExtendedRef:type': {
                return StereotypeTypeExtended;
            }
            case 'SystemsRelationCategoryExtendedRef:type': {
                return SystemsRelationCategoryExtended;
            }
            case 'SystemsRelationTypeExtendedRef:type': {
                return SystemsRelationTypeExtended;
            }
            case 'SystemSubTypeExtendedRef:type': {
                return SystemSubTypeExtended;
            }
            case 'SystemTypeExtendedRef:type': {
                return SystemTypeExtended;
            }
            case 'TestScenario:variable': {
                return TestVariable;
            }
            case 'TestScenarioTypeExtendedRef:type': {
                return TestScenarioTypeExtended;
            }
            case 'TestsRelation:source':
            case 'TestsRelation:target': {
                return Test;
            }
            case 'TestsRelationTypeExtendedRef:type': {
                return TestsRelationTypeExtended;
            }
            case 'TestTypeExtendedRef:type': {
                return TestTypeExtended;
            }
            case 'UCExtends:extensionPoint': {
                return UCExtensionPoint;
            }
            case 'UseCase:triggeredBy': {
                return ActiveEvent;
            }
            case 'UseCaseTypeExtendedRef:type': {
                return UseCaseTypeExtended;
            }
            case 'UserStory:partOf': {
                return UserStory;
            }
            case 'UserStoryTypeExtendedRef:type': {
                return UserStoryTypeExtended;
            }
            case 'VulnerabilityAttackVectorExtendedRef:type': {
                return VulnerabilityAttackVectorExtended;
            }
            case 'VulnerabilitySubTypeExtendedRef:type': {
                return VulnerabilitySubTypeExtended;
            }
            case 'VulnerabilityTypeExtendedRef:type': {
                return VulnerabilityTypeExtended;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AcceptanceCriteria': {
                return {
                    name: 'AcceptanceCriteria',
                    mandatory: [
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'AcceptanceCriteriaScenario': {
                return {
                    name: 'AcceptanceCriteriaScenario',
                    mandatory: [
                        { name: 'given', type: 'array' },
                        { name: 'then', type: 'array' },
                        { name: 'when', type: 'array' }
                    ]
                };
            }
            case 'AcceptanceCriteriaTest': {
                return {
                    name: 'AcceptanceCriteriaTest',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'ActiveEvent': {
                return {
                    name: 'ActiveEvent',
                    mandatory: [
                        { name: 'isFinal', type: 'boolean' },
                        { name: 'isInitial', type: 'boolean' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'ActiveFlow': {
                return {
                    name: 'ActiveFlow',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'ActiveTask': {
                return {
                    name: 'ActiveTask',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Actor': {
                return {
                    name: 'Actor',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Constraint': {
                return {
                    name: 'Constraint',
                    mandatory: [
                        { name: 'acceptanceCriteria', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'isNegative', type: 'boolean' },
                        { name: 'isPositive', type: 'boolean' },
                        { name: 'isProblem', type: 'boolean' },
                        { name: 'isSolution', type: 'boolean' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Data': {
                return {
                    name: 'Data',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'DataAttribute': {
                return {
                    name: 'DataAttribute',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'DataAttributeConstraint': {
                return {
                    name: 'DataAttributeConstraint',
                    mandatory: [
                        { name: 'checks', type: 'array' }
                    ]
                };
            }
            case 'DataAttributeRefs': {
                return {
                    name: 'DataAttributeRefs',
                    mandatory: [
                        { name: 'attributeRef', type: 'array' }
                    ]
                };
            }
            case 'DataAttributeRefsList': {
                return {
                    name: 'DataAttributeRefsList',
                    mandatory: [
                        { name: 'attributeRef', type: 'array' }
                    ]
                };
            }
            case 'DataAttributeTableRow': {
                return {
                    name: 'DataAttributeTableRow',
                    mandatory: [
                        { name: 'attributeValues', type: 'array' }
                    ]
                };
            }
            case 'DataAttributeValues': {
                return {
                    name: 'DataAttributeValues',
                    mandatory: [
                        { name: 'tableRows', type: 'array' }
                    ]
                };
            }
            case 'DataEntity': {
                return {
                    name: 'DataEntity',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'DataEntityCluster': {
                return {
                    name: 'DataEntityCluster',
                    mandatory: [
                        { name: 'children', type: 'array' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'DataEntityConstraint': {
                return {
                    name: 'DataEntityConstraint',
                    mandatory: [
                        { name: 'checks', type: 'array' }
                    ]
                };
            }
            case 'DataEntityTest': {
                return {
                    name: 'DataEntityTest',
                    mandatory: [
                        { name: 'tags', type: 'array' },
                        { name: 'testDataAttributes', type: 'array' }
                    ]
                };
            }
            case 'DataEnumeration': {
                return {
                    name: 'DataEnumeration',
                    mandatory: [
                        { name: 'tags', type: 'array' },
                        { name: 'values', type: 'array' }
                    ]
                };
            }
            case 'DataVariableRefs': {
                return {
                    name: 'DataVariableRefs',
                    mandatory: [
                        { name: 'variableRef', type: 'array' }
                    ]
                };
            }
            case 'DataVariableTableRow': {
                return {
                    name: 'DataVariableTableRow',
                    mandatory: [
                        { name: 'variableValues', type: 'array' }
                    ]
                };
            }
            case 'DataVariableValues': {
                return {
                    name: 'DataVariableValues',
                    mandatory: [
                        { name: 'tableRows', type: 'array' }
                    ]
                };
            }
            case 'ElementsRelation': {
                return {
                    name: 'ElementsRelation',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'FR': {
                return {
                    name: 'FR',
                    mandatory: [
                        { name: 'acceptanceCriteria', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'isNegative', type: 'boolean' },
                        { name: 'isPositive', type: 'boolean' },
                        { name: 'isProblem', type: 'boolean' },
                        { name: 'isSolution', type: 'boolean' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'GlossaryTerm': {
                return {
                    name: 'GlossaryTerm',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Goal': {
                return {
                    name: 'Goal',
                    mandatory: [
                        { name: 'acceptanceCriteria', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'isNegative', type: 'boolean' },
                        { name: 'isPositive', type: 'boolean' },
                        { name: 'isProblem', type: 'boolean' },
                        { name: 'isSolution', type: 'boolean' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'IncludeAll': {
                return {
                    name: 'IncludeAll',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'IncludeElement': {
                return {
                    name: 'IncludeElement',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'MainScenario': {
                return {
                    name: 'MainScenario',
                    mandatory: [
                        { name: 'steps', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'packages', type: 'array' }
                    ]
                };
            }
            case 'PackageSystem': {
                return {
                    name: 'PackageSystem',
                    mandatory: [
                        { name: 'imports', type: 'array' }
                    ]
                };
            }
            case 'QR': {
                return {
                    name: 'QR',
                    mandatory: [
                        { name: 'acceptanceCriteria', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'isNegative', type: 'boolean' },
                        { name: 'isPositive', type: 'boolean' },
                        { name: 'isProblem', type: 'boolean' },
                        { name: 'isSolution', type: 'boolean' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'RefActiveElement': {
                return {
                    name: 'RefActiveElement',
                    mandatory: [
                        { name: 'refActiveElement', type: 'array' }
                    ]
                };
            }
            case 'RefActor': {
                return {
                    name: 'RefActor',
                    mandatory: [
                        { name: 'refs', type: 'array' }
                    ]
                };
            }
            case 'RefDataEntity': {
                return {
                    name: 'RefDataEntity',
                    mandatory: [
                        { name: 'refDataEntity', type: 'array' }
                    ]
                };
            }
            case 'ReferenceElements': {
                return {
                    name: 'ReferenceElements',
                    mandatory: [
                        { name: 'references', type: 'array' }
                    ]
                };
            }
            case 'RefRequirements': {
                return {
                    name: 'RefRequirements',
                    mandatory: [
                        { name: 'refs', type: 'array' }
                    ]
                };
            }
            case 'RefSystems': {
                return {
                    name: 'RefSystems',
                    mandatory: [
                        { name: 'refs', type: 'array' }
                    ]
                };
            }
            case 'RefTermApplicableTo': {
                return {
                    name: 'RefTermApplicableTo',
                    mandatory: [
                        { name: 'refs', type: 'array' }
                    ]
                };
            }
            case 'RefUC': {
                return {
                    name: 'RefUC',
                    mandatory: [
                        { name: 'refs', type: 'array' }
                    ]
                };
            }
            case 'RequirementsRelation': {
                return {
                    name: 'RequirementsRelation',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Risk': {
                return {
                    name: 'Risk',
                    mandatory: [
                        { name: 'acceptanceCriteria', type: 'array' },
                        { name: 'refVulnerabilities', type: 'array' },
                        { name: 'tags', type: 'array' },
                        { name: 'treatments', type: 'array' }
                    ]
                };
            }
            case 'Scenario': {
                return {
                    name: 'Scenario',
                    mandatory: [
                        { name: 'steps', type: 'array' }
                    ]
                };
            }
            case 'Stakeholder': {
                return {
                    name: 'Stakeholder',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'State': {
                return {
                    name: 'State',
                    mandatory: [
                        { name: 'isFinal', type: 'boolean' },
                        { name: 'isInitial', type: 'boolean' },
                        { name: 'states', type: 'array' },
                        { name: 'transitions', type: 'array' }
                    ]
                };
            }
            case 'StateMachine': {
                return {
                    name: 'StateMachine',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'StateMachineTest': {
                return {
                    name: 'StateMachineTest',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'StateSequence': {
                return {
                    name: 'StateSequence',
                    mandatory: [
                        { name: 'refState', type: 'array' }
                    ]
                };
            }
            case 'Step': {
                return {
                    name: 'Step',
                    mandatory: [
                        { name: 'scenarios', type: 'array' }
                    ]
                };
            }
            case 'Stereotype': {
                return {
                    name: 'Stereotype',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'System': {
                return {
                    name: 'System',
                    mandatory: [
                        { name: 'isFinal', type: 'boolean' },
                        { name: 'isReusable', type: 'boolean' },
                        { name: 'isTestSuite', type: 'boolean' },
                        { name: 'systemConcepts', type: 'array' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'SystemsRelation': {
                return {
                    name: 'SystemsRelation',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'TestOperationTarget': {
                return {
                    name: 'TestOperationTarget',
                    mandatory: [
                        { name: 'content', type: 'array' },
                        { name: 'variable', type: 'array' }
                    ]
                };
            }
            case 'TestScenario': {
                return {
                    name: 'TestScenario',
                    mandatory: [
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'testSteps', type: 'array' }
                    ]
                };
            }
            case 'TestsRelation': {
                return {
                    name: 'TestsRelation',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'TestVariable': {
                return {
                    name: 'TestVariable',
                    mandatory: [
                        { name: 'attributes', type: 'array' }
                    ]
                };
            }
            case 'Theme': {
                return {
                    name: 'Theme',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'UCActions': {
                return {
                    name: 'UCActions',
                    mandatory: [
                        { name: 'actions', type: 'array' }
                    ]
                };
            }
            case 'UCExtensionPoints': {
                return {
                    name: 'UCExtensionPoints',
                    mandatory: [
                        { name: 'extensionPoints', type: 'array' }
                    ]
                };
            }
            case 'UCIncludes': {
                return {
                    name: 'UCIncludes',
                    mandatory: [
                        { name: 'includes', type: 'array' }
                    ]
                };
            }
            case 'UpdateFields': {
                return {
                    name: 'UpdateFields',
                    mandatory: [
                        { name: 'updateFields', type: 'array' }
                    ]
                };
            }
            case 'UseCase': {
                return {
                    name: 'UseCase',
                    mandatory: [
                        { name: 'acceptanceCriteria', type: 'array' },
                        { name: 'extends', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'isNegative', type: 'boolean' },
                        { name: 'isPositive', type: 'boolean' },
                        { name: 'isProblem', type: 'boolean' },
                        { name: 'isSolution', type: 'boolean' },
                        { name: 'mainScenarios', type: 'array' },
                        { name: 'supportingActors', type: 'array' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'UseCaseTest': {
                return {
                    name: 'UseCaseTest',
                    mandatory: [
                        { name: 'scenarios', type: 'array' },
                        { name: 'tags', type: 'array' },
                        { name: 'variables', type: 'array' }
                    ]
                };
            }
            case 'UserStory': {
                return {
                    name: 'UserStory',
                    mandatory: [
                        { name: 'acceptanceCriteria', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'isConcrete', type: 'boolean' },
                        { name: 'isNegative', type: 'boolean' },
                        { name: 'isPositive', type: 'boolean' },
                        { name: 'isProblem', type: 'boolean' },
                        { name: 'isSolution', type: 'boolean' },
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'View': {
                return {
                    name: 'View',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            case 'Vulnerability': {
                return {
                    name: 'Vulnerability',
                    mandatory: [
                        { name: 'tags', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new RslAstReflection();
